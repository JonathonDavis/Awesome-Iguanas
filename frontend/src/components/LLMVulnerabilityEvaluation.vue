<template>
  <div class="llm-vulnerability-evaluation">
    <h2><i class="fas fa-shield-alt"></i> LLM Vulnerability Analysis</h2>
    
    <div v-if="loading" class="loading-container">
      <div class="spinner-ring"></div>
      <p class="loading-text">
        <span class="loading-title">Analyzing with AI...</span>
        <span class="loading-subtitle">Scanning code patterns and identifying potential vulnerabilities</span>
      </p>
    </div>
    
    <div v-if="error" class="error-container">
      <div class="error-icon"><i class="fas fa-exclamation-triangle"></i></div>
      <div class="error-content">
        <p class="error-message">{{ error }}</p>
        <button @click="retryEvaluation" class="btn btn-primary">
          <i class="fas fa-redo"></i> Retry Analysis
        </button>
      </div>
    </div>
    
    <div class="tabs-container">
      <div class="tabs-wrapper">
        <div 
          :class="['tab-item', { active: activeTab === 'upload' }]"
          @click="switchTab('upload')"
        >
          <div class="tab-icon"><i class="fas fa-upload"></i></div>
          <div class="tab-label">Upload Repository</div>
          <div class="tab-indicator"></div>
        </div>
        <div 
          :class="['tab-item', { active: activeTab === 'select' }]"
          @click="switchTab('select')"
        >
          <div class="tab-icon"><i class="fas fa-database"></i></div>
          <div class="tab-label">Select Repository</div>
          <div class="tab-indicator"></div>
        </div>
      </div>
      <div class="tab-content">
        <div :class="['tab-panel', { active: activeTab === 'upload' }]">
          <div 
            class="upload-area" 
            @dragover.prevent="onDragOver" 
            @drop.prevent="onDrop"
            @dragleave.prevent="event => event.target.classList.remove('drag-over')"
          >
            <input 
              type="file" 
              ref="fileInput" 
              @change="handleFileUpload" 
              webkitdirectory directory multiple
              style="display: none"
            />
            <div class="upload-content" @click="triggerFileInput">
              <div class="upload-icon-container">
                <div class="folder-icon">
                  <div class="folder-back"></div>
                  <div class="folder-front"></div>
                  <div class="upload-arrow">
                    <i class="fas fa-arrow-down"></i>
                  </div>
                  <div class="file-icons">
                    <div class="file file1"><i class="fas fa-code"></i></div>
                    <div class="file file2"><i class="fas fa-file-code"></i></div>
                    <div class="file file3"><i class="fas fa-file-alt"></i></div>
                  </div>
                </div>
              </div>
              <h3 class="upload-title">Drag & Drop Repository</h3>
              <p class="upload-text">Drop your code folder here or click to browse</p>
              <div class="upload-help-box">
                <i class="fas fa-info-circle"></i>
                <span>For best results, upload a complete repository with source code files</span>
              </div>
            </div>
          </div>
          
          <div v-if="uploadedFiles.length > 0" class="uploaded-files">
            <div class="uploaded-header">
              <div class="file-count">
                <i class="fas fa-folder-open"></i>
                <span>{{ uploadedFiles.length }} files uploaded</span>
              </div>
              <div class="file-analysis-count">
                <i class="fas fa-code"></i>
                <span>{{ filteredFiles.length }} files will be analyzed</span>
              </div>
            </div>
            
            <div class="file-types-summary">
              <div class="file-type-badge javascript">JS</div>
              <div class="file-type-badge python">PY</div>
              <div class="file-type-badge java">JAVA</div>
              <div class="file-type-badge other">Other</div>
            </div>
            
            <div class="file-actions">
              <button @click="clearUpload" class="btn btn-secondary">
                <i class="fas fa-trash-alt"></i> Clear Files
              </button>
              <button @click="evaluateUploadedFiles" class="btn btn-primary">
                <i class="fas fa-search"></i> Analyze Code
              </button>
            </div>
          </div>
        </div>
        
        <div :class="['tab-panel', { active: activeTab === 'select' }]">
          <div class="repository-selector">
            <div class="select-group">
              <label for="repository" class="select-label">
                <i class="fas fa-server"></i> Repository
              </label>
              <div class="select-wrapper">
                <select id="repository" v-model="selectedRepository" @change="onRepositoryChange" class="enhanced-select">
                  <option v-for="repo in repositories" :key="repo.id" :value="repo">
                    {{ repo.url }}
                  </option>
                </select>
              </div>
            </div>
            <div class="select-group">
              <label for="version" class="select-label">
                <i class="fas fa-code-branch"></i> Version
              </label>
              <div class="select-wrapper">
                <select id="version" v-model="selectedVersion" @change="onVersionChange" class="enhanced-select" :disabled="!versions.length">
                  <option v-if="versions.length === 0" value="">No versions available</option>
                  <option v-for="version in versions" :key="version.version" :value="version">
                    {{ version.version }}
                  </option>
                </select>
              </div>
            </div>
            
            <button @click="evaluateRevision" class="btn btn-primary run-analysis-btn" :disabled="!selectedRepository">
              <i class="fas fa-brain"></i> Run LLM Analysis
            </button>
          </div>
          
          <div v-if="!selectedRepository && !loading && !error" class="empty-repo-state">
            <i class="fas fa-database"></i>
            <p>No repositories available. Please add repositories to the database first.</p>
          </div>
        </div>
      </div>
    </div>
    
    <div v-if="evaluationResults.length > 0" class="results-container">
      <div class="results-header">
        <h3><i class="fas fa-chart-pie"></i> Analysis Results</h3>
      </div>
      
      <div class="metrics-panel" v-if="metrics">
        <div class="metrics-header">
          <h4>Vulnerability Metrics</h4>
          <span class="metrics-subtitle">AI-powered vulnerability detection summary</span>
        </div>
        <div class="metrics-grid">
          <div class="metric total">
            <div class="metric-icon">
              <i class="fas fa-clipboard-check"></i>
            </div>
            <div class="metric-content">
              <p class="metric-value">{{ metrics.totalEvaluations }}</p>
              <p class="metric-label">Total Evaluations</p>
            </div>
          </div>
          <div class="metric high">
            <div class="metric-icon">
              <i class="fas fa-exclamation-circle"></i>
            </div>
            <div class="metric-content">
              <p class="metric-value">{{ metrics.classificationDistribution['very promising'] || 0 }}</p>
              <p class="metric-label">Very Promising</p>
            </div>
          </div>
          <div class="metric medium">
            <div class="metric-icon">
              <i class="fas fa-exclamation"></i>
            </div>
            <div class="metric-content">
              <p class="metric-value">{{ metrics.classificationDistribution['slightly promising'] || 0 }}</p>
              <p class="metric-label">Slightly Promising</p>
            </div>
          </div>
          <div class="metric low">
            <div class="metric-icon">
              <i class="fas fa-info-circle"></i>
            </div>
            <div class="metric-content">
              <p class="metric-value">{{ metrics.classificationDistribution['not promising'] || 0 }}</p>
              <p class="metric-label">Not Promising</p>
            </div>
          </div>
        </div>
      </div>
          <div class="vulnerability-filter">
        <div class="filter-label"><i class="fas fa-filter"></i> Filter:</div>
        <div class="filter-options">
          <button @click="setFilter('all')" :class="['filter-btn', {'active': selectedFilter === 'all'}]">All</button>
          <button @click="setFilter('very promising')" :class="['filter-btn very-promising', {'active': selectedFilter === 'very promising'}]">Very Promising</button>
          <button @click="setFilter('slightly promising')" :class="['filter-btn slightly-promising', {'active': selectedFilter === 'slightly promising'}]">Slightly Promising</button>
          <button @click="setFilter('not promising')" :class="['filter-btn not-promising', {'active': selectedFilter === 'not promising'}]">Not Promising</button>
        </div>
      </div>
          <div class="vulnerability-cards">
        <div 
          v-for="result in filteredEvaluationResults" 
          :key="result.vulnerabilityId" 
          :class="['vulnerability-card', `classification-${result.classification.replace(' ', '-')}`]"
        >
          <div class="card-indicator"></div>
          <div class="card-header">
            <div class="header-content">
              <h3>{{ result.headline }}</h3>
              <span :class="['classification-badge', result.classification.replace(' ', '-')]">
                <i class="classification-icon" 
                   :class="result.classification === 'very promising' ? 'fas fa-exclamation-circle' : 
                           result.classification === 'slightly promising' ? 'fas fa-exclamation' : 
                           'fas fa-info-circle'"></i>
                {{ result.classification }}
              </span>
            </div>
            <span class="vulnerability-id">ID: {{ result.vulnerabilityId }}</span>
          </div>
          
          <div class="card-content">
            <div class="analysis-section">
              <h4><i class="fas fa-search"></i> Analysis</h4>
              <p class="analysis">{{ result.analysis }}</p>
            </div>
            
            <div class="details-grid">
              <div class="detail-section">
                <h4><i class="fas fa-bug"></i> CVE Type</h4>
                <div class="detail-content">
                  <span class="cve-badge">{{ result.cve }}</span>
                </div>
              </div>
              
              <div class="detail-section">
                <h4><i class="fas fa-code"></i> Concerned Functions</h4>
                <div class="detail-content scrollable">
                  <ul class="function-list">
                    <li v-for="(func, idx) in result.concernedFunctions" :key="idx">
                      <i class="fas fa-function"></i> {{ func }}
                    </li>
                    <li v-if="result.concernedFunctions.length === 0" class="empty-list">No specific functions identified</li>
                  </ul>
                </div>
              </div>
              
              <div class="detail-section">
                <h4><i class="fas fa-file-code"></i> Concerned Files</h4>
                <div class="detail-content scrollable">
                  <ul class="file-list">
                    <li v-for="(file, idx) in result.concernedFiles" :key="idx">
                      <i class="fas fa-file"></i> {{ file }}
                    </li>
                    <li v-if="result.concernedFiles.length === 0" class="empty-list">No specific files identified</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>    <div v-else-if="!loading && selectedVersion" class="no-results">
      <div class="empty-state">
        <i class="fas fa-search"></i>
        <h3>No Vulnerabilities Found</h3>
        <p>No vulnerability evaluations are available for this selection. Run an LLM analysis to examine potential security issues.</p>
        <button @click="evaluateRevision" class="btn btn-primary" :disabled="loading">
          <i class="fas fa-brain"></i> Run Analysis Now
        </button>
      </div>
    </div>
    <!-- Progress Tracking Section -->
    <div v-if="isEvaluating || progressHistory.length > 0" class="progress-container">
      <h3>Evaluation Progress</h3>
      
      <div class="progress-bar-container" v-if="currentProgress">
        <div class="progress-bar" :style="{ width: progressPercentage + '%' }"></div>
        <div class="progress-status">{{ currentProgress.status }}</div>
      </div>
      
      <div class="progress-message" v-if="currentProgress">
        {{ currentProgress.message }}
      </div>
      
      <div class="progress-history">
        <h4>Progress Checkpoints</h4>
        <ul class="checkpoint-list">
          <li v-for="(checkpoint, index) in progressHistory" :key="index" 
              :class="['checkpoint', checkpoint.status]">
            <span class="checkpoint-time">
              {{ new Date(checkpoint.timestamp).toLocaleTimeString() }}
            </span>
            <span class="checkpoint-status">{{ checkpoint.status }}</span>
            <span class="checkpoint-message">{{ checkpoint.message }}</span>
          </li>
        </ul>
      </div>
    </div>
  </div>
</template>

<script>
import neo4jService from '../services/neo4j/neo4jService';
import { LLMVulnerabilityEvaluator } from '../services/neo4j/llmVulnerabilityEvaluator';

export default {
  name: 'LLMVulnerabilityEvaluation',
  
  computed: {
    filteredEvaluationResults() {
      if (this.selectedFilter === 'all') {
        return this.evaluationResults;
      } else {
        return this.evaluationResults.filter(result => result.classification === this.selectedFilter);
      }
    },
    progressPercentage() {
      if (!this.currentProgress || !this.currentProgress.total) {
        return 0;
      }
      return Math.min((this.currentProgress.completed / this.currentProgress.total) * 100, 100);
    }
  },
    data() {
    return {
      repositories: [],
      selectedRepository: null,
      versions: [],
      selectedVersion: null,
      evaluationResults: [],
      loading: false,
      error: null,
      neo4jService: null,
      llmEvaluator: null,
      metrics: null,
      activeTab: 'upload', // Default to the upload tab
      uploadedFiles: [],
      filteredFiles: [],
      selectedFilter: 'all', // Track the current filter selection
      // Extensions and paths to block in analysis
      blockedExtensions: [
        '.css', '.lock', '.md', '.min.js', '.scss', '.txt', '.rst', 
        '.json', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', 
        '.eot', '.ttf', '.woff', '.woff2', '.map', '.yaml', '.yml'
      ],
      maxFileSize: 200000, // 200,000 characters limit
      isEvaluating: false,
      progressHistory: [],
      currentProgress: null,
      repositoryId: null
    };
  },
    async created() {
    try {
      // Use the neo4j service singleton instance
      this.neo4jService = neo4jService;
      this.llmEvaluator = new LLMVulnerabilityEvaluator(this.neo4jService.driver);
      
      await this.loadRepositories();
      
      // Calculate metrics
      this.metrics = await this.llmEvaluator.calculateEvaluationMetrics();
    } catch (error) {
      this.error = `Failed to initialize: ${error.message}`;
    }
  },
  mounted() {
    // Listen for progress updates
    window.addEventListener('llm-evaluation-progress', this.handleProgressUpdate);
  },
  
  beforeUnmount() {
    // Clean up event listener
    window.removeEventListener('llm-evaluation-progress', this.handleProgressUpdate);
  },
  
  methods: {    async loadRepositories() {
      try {
        const session = this.neo4jService.driver.session();
        const result = await session.run(`
          MATCH (r:Repository)
          RETURN r.id AS id, r.url AS url, ID(r) AS nodeId
          ORDER BY r.url
        `);
        
        this.repositories = result.records.map(record => {
          const url = record.get('url');
          // Use the repository ID if available, otherwise use URL as a fallback ID
          // If neither is available, use the Neo4j internal node ID as a last resort
          const id = record.get('id') || url || `node-${record.get('nodeId')}`;
          
          console.log(`Repository: ${url}, ID: ${id}`);
          
          return {
            id: id,
            url: url
          };
        });
        
        if (this.repositories.length > 0) {
          this.selectedRepository = this.repositories[0];
          await this.onRepositoryChange();
        }
        
        await session.close();
      } catch (error) {
        this.error = `Failed to load repositories: ${error.message}`;
      }
    },
    async onRepositoryChange() {
      if (!this.selectedRepository) return;
      this.selectedVersion = null; // Reset selected version when repository changes
      this.evaluationResults = []; // Clear previous results
      
      try {
        const session = this.neo4jService.driver.session();
        const result = await session.run(`
          MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version)
          RETURN v.id AS id, v.version AS version
          ORDER BY v.version DESC
        `, { repoId: this.selectedRepository.id });
        
        this.versions = result.records.map(record => ({
          id: record.get('id'),
          version: record.get('version')
        }));
        
        console.log(`Loaded ${this.versions.length} versions for repository ${this.selectedRepository.url}`);
        
        if (this.versions.length > 0) {
          this.selectedVersion = this.versions[0];
          await this.onVersionChange();
        } else {
          console.warn('No versions found for selected repository');
          
          // Add a default "Latest" version option for repositories without versions
          this.versions = [{
            id: 'latest',
            version: 'Latest'
          }];
          this.selectedVersion = this.versions[0];
          
          // Enable direct repository analysis without requiring a specific version
          this.canRunAnalysis = true;
        }
        
        await session.close();
      } catch (error) {
        console.error('Error loading versions:', error);
        this.error = `Failed to load versions: ${error.message}`;
      }
    },    async onVersionChange() {
      if (!this.selectedRepository || !this.selectedVersion) return;
      
      try {
        this.loading = true;
        const session = this.neo4jService.driver.session();
        const result = await session.run(`
          MATCH (v:Version {id: $versionId})-[:HAS_EVALUATION]->(e:LLMEvaluation)-[:EVALUATES]->(vuln:Vulnerability)
          RETURN e.headline AS headline,
                 e.analysis AS analysis,
                 e.cve AS cve,
                 e.concernedFunctions AS concernedFunctions,
                 e.concernedFiles AS concernedFiles,
                 e.classification AS classification,
                 vuln.id AS vulnerabilityId
        `, { versionId: this.selectedVersion.id });
        
        this.evaluationResults = result.records.map(record => ({
          vulnerabilityId: record.get('vulnerabilityId'),
          headline: record.get('headline'),
          analysis: record.get('analysis'),
          cve: record.get('cve'),
          concernedFunctions: record.get('concernedFunctions') || [],
          concernedFiles: record.get('concernedFiles') || [],
          classification: record.get('classification') || 'not promising'
        }));
        
        await session.close();
      } catch (error) {
        this.error = `Failed to load evaluation results: ${error.message}`;
      } finally {
        this.loading = false;
      }
    },
    
    async loadRepositoryEvaluations(repositoryId) {
      try {
        this.loading = true;
        const session = this.neo4jService.driver.session();
        const result = await session.run(`
          MATCH (r:Repository {id: $repoId})-[:HAS_EVALUATION]->(e:LLMEvaluation)-[:EVALUATES]->(vuln:Vulnerability)
          RETURN e.headline AS headline,
                 e.analysis AS analysis,
                 e.cve AS cve,
                 e.concernedFunctions AS concernedFunctions,
                 e.concernedFiles AS concernedFiles,
                 e.classification AS classification,
                 vuln.id AS vulnerabilityId
        `, { repoId: repositoryId });
        
        this.evaluationResults = result.records.map(record => ({
          vulnerabilityId: record.get('vulnerabilityId'),
          headline: record.get('headline'),
          analysis: record.get('analysis'),
          cve: record.get('cve'),
          concernedFunctions: record.get('concernedFunctions') || [],
          concernedFiles: record.get('concernedFiles') || [],
          classification: record.get('classification') || 'not promising'
        }));
        
        await session.close();
      } catch (error) {
        this.error = `Failed to load repository evaluation results: ${error.message}`;
      } finally {
        this.loading = false;
      }
    },// File upload handling methods
    triggerFileInput() {
      this.$refs.fileInput.click();
    },
    
    onDragOver(event) {
      event.preventDefault();
      event.target.classList.add('drag-over');
    },
    
    onDrop(event) {
      event.preventDefault();
      event.target.classList.remove('drag-over');
      
      if (event.dataTransfer.items) {
        // Use DataTransferItemList interface to access the files
        this.processDroppedItems(event.dataTransfer.items);
      } else if (event.dataTransfer.files) {
        // Use DataTransfer interface to access the files
        this.handleFiles(Array.from(event.dataTransfer.files));
      }
    },
    
    processDroppedItems(items) {
      const files = [];
      
      const readEntries = async (entry, path = '') => {
        return new Promise(resolve => {
          if (entry.isFile) {
            entry.file(file => {
              file.relativePath = path + file.name;
              files.push(file);
              resolve();
            });
          } else if (entry.isDirectory) {
            const dirReader = entry.createReader();
            const readBatch = () => {
              dirReader.readEntries(entries => {
                if (entries.length > 0) {
                  Promise.all(entries.map(entry => {
                    return readEntries(entry, path + entry.name + '/');
                  })).then(() => {
                    readBatch();
                  });
                } else {
                  resolve();
                }
              });
            };
            readBatch();
          }
        });
      };
      
      const processItems = async () => {
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item.kind === 'file') {
            const entry = item.webkitGetAsEntry();
            if (entry) {
              await readEntries(entry);
            }
          }
        }
        this.handleFiles(files);
      };
      
      processItems();
    },
    
    handleFileUpload(event) {
      if (event.target.files) {
        this.handleFiles(Array.from(event.target.files));
      }
    },
    
    handleFiles(files) {
      this.uploadedFiles = files;
      this.filterFiles();
    },
      setFilter(filter) {
      // Update the selected filter
      this.selectedFilter = filter;
    },
    
    filterFiles() {
      // Apply filtering rules:
      // 1. Exclude files with blocklisted extensions
      // 2. Exclude files in paths starting with "."
      // 3. Exclude files larger than 200,000 characters
      // 4. Exclude files with non-text MIME types
      this.filteredFiles = this.uploadedFiles.filter(file => {
        // Check file extension
        const extension = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
        if (this.blockedExtensions.includes(extension)) return false;
        
        // Check path for dot files/directories
        if (file.relativePath) {
          const pathParts = file.relativePath.split('/');
          if (pathParts.some(part => part.startsWith('.'))) return false;
        }
        
        // Check file size - we'll do a rough conversion from bytes to characters
        // This is an approximation as the actual character count depends on encoding
        if (file.size > this.maxFileSize) return false;
        
        // Check MIME type - simple heuristic for text files
        if (!file.type.startsWith('text/') && 
            !file.name.match(/\.(js|ts|jsx|tsx|py|java|c|cpp|h|hpp|cs|rb|php|html|xml|go|rust|sol)$/i)) {
          // Try to identify code files not properly recognized by MIME type
          return false;
        }
        
        return true;
      });
    },
    
    clearUpload() {
      this.uploadedFiles = [];
      this.filteredFiles = [];
      this.$refs.fileInput.value = null;
    },
    
    async evaluateUploadedFiles() {
      if (this.filteredFiles.length === 0) {
        this.error = "No valid files to analyze. Please upload source code files.";
        return;
      }
      
      try {
        this.loading = true;
        this.error = null;
        const uploadedCodebase = [];
        
        // Read file contents and prepare for analysis
        for (const file of this.filteredFiles) {
          const content = await this.readFileContent(file);
          uploadedCodebase.push({
            path: file.relativePath || file.name,
            content: content,
            mimeType: file.type,
            size: file.size
          });
        }
        
        // Create a temporary repository ID for the uploaded codebase
        const temporaryRepoId = 'uploaded_' + Date.now();
        
        // Use custom method to evaluate the uploaded codebase
        const results = await this.evaluateUploadedCodebase(uploadedCodebase, temporaryRepoId);
        
        // Update the evaluation results
        this.evaluationResults = results;
        
      } catch (error) {
        this.error = `Failed to analyze uploaded files: ${error.message}`;
      } finally {
        this.loading = false;
      }
    },
    
    async readFileContent(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = (e) => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    },
    
    async evaluateUploadedCodebase(codeFiles, temporaryRepoId) {
      try {
        // Fetch common vulnerabilities that could be relevant
        const vulnerabilities = await this.getCommonVulnerabilities();
        const results = [];
        
        for (const vuln of vulnerabilities) {
          // Construct a prompt for the LLM to evaluate this vulnerability
          const prompt = this.constructLLMPrompt(codeFiles, vuln);
          
          // Use the proxy path instead of direct Ollama API URL to avoid CORS issues
          const response = await fetch(`/ollama-api/api/generate`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: import.meta.env.VITE_OLLAMA_MODEL || 'llama2:latest',
              prompt: prompt,
              stream: false
            })
          });
          
          if (!response.ok) {
            throw new Error(`Ollama API error: ${response.status}`);
          }
          
          const data = await response.json();
          
          // Parse the response to extract structured data
          const result = this.parseLLMResponse(data.response, vuln);
          results.push(result);
        }
        
        // Update metrics after evaluation
        await this.updateMetricsWithResults(results);
        
        return results;
      } catch (error) {
        console.error('Error evaluating uploaded codebase:', error);
        throw error;
      }
    },
    
    constructLLMPrompt(codeFiles, vulnerability) {
      // Include only the first 10 files to avoid token limits
      const MAX_FILES = 10;
      const selectedFiles = codeFiles.slice(0, MAX_FILES);
      
      // Format the code snippets
      const codeSnippets = selectedFiles.map(file => 
        `File: ${file.path}\n\`\`\`\n${file.content}\n\`\`\``
      ).join('\n\n');
      
      // Format CVE information
      const cveInfo = vulnerability.cveIds && vulnerability.cveIds.length > 0 
        ? vulnerability.cveIds.join(', ') 
        : 'No specific CVE';
      
      // Prepare the prompt
      return `You are a security expert analyzing code for potential vulnerabilities.
      
VULNERABILITY DETAILS:
ID: ${vulnerability.id}
Summary: ${vulnerability.summary || 'Not provided'}
Details: ${vulnerability.details || 'Not provided'}
CVE(s): ${cveInfo}

CODE TO ANALYZE:
${codeSnippets}

INSTRUCTIONS:
1. Analyze the code for the specified vulnerability.
2. Provide a concise headline for the vulnerability.
3. Write a detailed analysis of how the vulnerability affects this codebase.
4. Identify the most relevant CVE type for this vulnerability.
5. List the most concerned functions in the code (those most likely affected).
6. List the most concerned filenames in the codebase.
7. Classify the likelihood of this vulnerability being present as one of: "very promising", "slightly promising", or "not promising".

Format your response exactly like this:
HEADLINE: [Vulnerability headline]
ANALYSIS: [Detailed analysis]
RELEVANT_CVE: [Most relevant CVE type]
CONCERNED_FUNCTIONS: [List of functions, comma-separated]
CONCERNED_FILES: [List of filenames, comma-separated]
CLASSIFICATION: [very promising|slightly promising|not promising]

Be precise and concise. Base your classification strictly on the evidence in the code.`;
    },
    
    parseLLMResponse(response, vulnerability) {
      const result = {
        vulnerabilityId: vulnerability.id,
        headline: '',
        analysis: '',
        cve: '',
        concernedFunctions: [],
        concernedFiles: [],
        classification: 'not promising' // default
      };
      
      // Extract the headline
      const headlineMatch = response.match(/HEADLINE:\s*(.+?)(?=\n|ANALYSIS:)/s);
      if (headlineMatch) {
        result.headline = headlineMatch[1].trim();
      }
      
      // Extract the analysis
      const analysisMatch = response.match(/ANALYSIS:\s*(.+?)(?=\n|RELEVANT_CVE:)/s);
      if (analysisMatch) {
        result.analysis = analysisMatch[1].trim();
      }
      
      // Extract the CVE
      const cveMatch = response.match(/RELEVANT_CVE:\s*(.+?)(?=\n|CONCERNED_FUNCTIONS:)/s);
      if (cveMatch) {
        result.cve = cveMatch[1].trim();
      }
      
      // Extract concerned functions
      const functionsMatch = response.match(/CONCERNED_FUNCTIONS:\s*(.+?)(?=\n|CONCERNED_FILES:)/s);
      if (functionsMatch) {
        result.concernedFunctions = functionsMatch[1]
          .split(',')
          .map(func => func.trim())
          .filter(Boolean);
      }
      
      // Extract concerned files
      const filesMatch = response.match(/CONCERNED_FILES:\s*(.+?)(?=\n|CLASSIFICATION:)/s);
      if (filesMatch) {
        result.concernedFiles = filesMatch[1]
          .split(',')
          .map(file => file.trim())
          .filter(Boolean);
      }
      
      // Extract classification
      const classMatch = response.match(/CLASSIFICATION:\s*(.+?)(?=\n|$)/s);
      if (classMatch) {
        const classification = classMatch[1].trim().toLowerCase();
        if (["very promising", "slightly promising", "not promising"].includes(classification)) {
          result.classification = classification;
        }
      }
      
      return result;
    },
    
    async getCommonVulnerabilities() {
      try {
        // Use the llmEvaluator to get vulnerabilities from the database
        return await this.llmEvaluator.getRelevantVulnerabilitiesForRepo('common');
      } catch (error) {
        console.error('Error fetching vulnerabilities from database:', error);
        
        // Only use emergency fallback if there's an error
        return await this.llmEvaluator.getEmergencyCommonVulnerabilities();
      }
    },
    
    async updateMetricsWithResults(results) {
      // Update metrics based on new evaluation results
      if (!this.metrics) {
        this.metrics = {
          totalEvaluations: 0,
          classificationDistribution: {
            'very promising': 0,
            'slightly promising': 0,
            'not promising': 0
          }
        };
      }
      
      // Update classification counts
      results.forEach(result => {
        this.metrics.totalEvaluations++;
        if (this.metrics.classificationDistribution.hasOwnProperty(result.classification)) {
          this.metrics.classificationDistribution[result.classification]++;
        }
      });
    },    async evaluateRevision() {
      if (!this.selectedRepository) {
        console.error("No repository selected");
        return;
      }
      
      try {
        this.isEvaluating = true;
        this.error = null;
        this.progressHistory = [];
        this.currentProgress = null;
        
        if (!this.repoUrl) {
          this.error = 'Please enter a repository URL';
          this.isEvaluating = false;
          return;
        }
        
        // First, get the repository ID
        const repoId = await this.llmEvaluator.getRepositoryId(this.repoUrl);
        this.repositoryId = repoId;
        
        // Load any existing progress history
        this.progressHistory = this.llmEvaluator.getProgressHistory(repoId) || [];
        
        // Start the evaluation process
        const results = await this.llmEvaluator.evaluateRepository(repoId);
        
        this.evaluationResults = results.evaluationResults;
      } catch (error) {
        this.error = `Error evaluating repository: ${error.message}`;
        console.error('Error evaluating repository:', error);
      } finally {
        this.isEvaluating = false;
      }
    },
    
    async analyzeUploadedFiles() {
      try {
        this.isEvaluating = true;
        this.error = '';
        this.progressHistory = [];
        this.currentProgress = null;
        
        if (!this.uploadedFiles || this.uploadedFiles.length === 0) {
          this.error = 'Please upload files to analyze';
          this.isEvaluating = false;
          return;
        }
        
        const results = await this.llmEvaluator.analyzeUploadedFiles(this.uploadedFiles);
        
        // Store the repository ID for future reference
        this.repositoryId = results.repositoryId;
        
        // Update progress history
        this.progressHistory = this.llmEvaluator.getProgressHistory(this.repositoryId) || [];
        
        this.evaluationResults = results.evaluationResults;
      } catch (error) {
        this.error = `Error analyzing files: ${error.message}`;
        console.error('Error analyzing files:', error);
      } finally {
        this.isEvaluating = false;
      }
    },
    
    handleProgressUpdate(event) {
      const { repositoryId, progress } = event.detail;
      
      // Only process events for the current repository
      if (this.repositoryId && repositoryId !== this.repositoryId) {
        // Special case: if this is a repository ID change notification, update our ID
        if (progress.newRepositoryId && repositoryId.startsWith('upload_')) {
          this.repositoryId = progress.newRepositoryId;
        }
        return;
      }
      
      // Update current progress
      this.currentProgress = progress;
      
      // Add to history if it's a new status
      if (this.progressHistory.length === 0 || 
          this.progressHistory[this.progressHistory.length - 1].status !== progress.status) {
        this.progressHistory.push(progress);
      } else {
        // Replace last item if same status but different message
        this.progressHistory[this.progressHistory.length - 1] = progress;
      }
    },
    
    retryEvaluation() {
      this.error = null;
      this.evaluateRevision();
    },
    switchTab(tab) {
      // Don't do anything if we're already on this tab
      if (this.activeTab === tab) return;
      
      // Reset state variables to avoid data leaking between tabs
      this.evaluationResults = [];
      this.error = null;
      
      if (tab === 'upload') {
        // Clear repository selection when switching to upload
        this.selectedRepository = null;
        this.selectedVersion = null;
        this.versions = [];
        
        // Keep any existing uploaded files
      } else if (tab === 'select') {
        // Clear uploaded files when switching to repository selection
        this.uploadedFiles = [];
        this.filteredFiles = [];
        
        // If we have repositories, select the first one
        if (this.repositories.length > 0 && !this.selectedRepository) {
          this.selectedRepository = this.repositories[0];
          this.onRepositoryChange();
        }
      }
      
      // Finally, set the active tab
      this.activeTab = tab;
    },
  }
}
</script>

<style scoped>
.llm-vulnerability-evaluation {
  padding: 1rem;
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2rem;
}

.spinner {
  border: 4px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top: 4px solid #3498db;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin-bottom: 1rem;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error-container {
  background-color: #ffeeee;
  border: 1px solid #ff6666;
  border-radius: 4px;
  padding: 1rem;
  margin: 1rem 0;
}

.error-message {
  color: #cc0000;
  margin-bottom: 0.5rem;
}

.repository-selector {
  margin-bottom: 1.5rem;
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.repository-selector select {
  padding: 0.5rem;
  border-radius: 4px;
  border: 1px solid #ccc;
  min-width: 200px;
}

.btn {
  background-color: #4CAF50;
  color: white;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

.btn:hover {
  background-color: #45a049;
}

.btn:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.ml-4 {
  margin-left: 1rem;
}

.results-container {
  margin-top: 2rem;
}

.metrics-panel {
  background-color: #f5f5f5;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 2rem;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 1rem;
  margin-top: 1rem;
}

.metric {
  text-align: center;
  padding: 1rem;
  background-color: white;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.metric-value {
  font-size: 1.5rem;
  font-weight: bold;
  margin: 0;
}

.metric-label {
  margin: 0.5rem 0 0;
  color: #666;
}

.vulnerability-cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 1.5rem;
}

.vulnerability-card {
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  border-top: 5px solid #ccc;
}

.classification-very-promising {
  border-top-color: #4dff56;
}

.classification-slightly-promising {
  border-top-color: #ffa64d;
}

.classification-not-promising {
  border-top-color: #910a0a;
}

.card-header {
  padding: 1rem;
  background-color: #f8f8f8;
  border-bottom: 1px solid #eee;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  gap: 0.5rem;
}

.card-header .header-content {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.5rem;
  flex: 1;
}

.card-header h3 {
  margin: 0;
  font-size: 1.2rem;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: normal;
}

.vulnerability-id {
  font-size: 0.8rem;
  color: #777;
  white-space: nowrap;
}

.classification-badge {
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: bold;
  white-space: nowrap;
}

.classification-very-promising .classification-badge {
  background-color: #d2ffcc;
  color: #00cc1b;
}

.classification-slightly-promising .classification-badge {
  background-color: #ffe0b3;
  color: #cc7000;
}

.classification-not-promising .classification-badge {
  background-color: #ffcccc;
  color: #cc0000;
}

.card-content {
  padding: 1rem;
}

.analysis {
  line-height: 1.5;
  margin-bottom: 1.5rem;
  color: #333;
}

.detail-section {
  margin-bottom: 1rem;
}

.detail-section h4 {
  font-size: 1rem;
  margin-bottom: 0.5rem;
  color: #555;
}

.detail-section ul {
  list-style-type: disc;
  margin-left: 1.25rem;
  padding-left: 0;
}

.no-results {
  background-color: #f9f9f9;
  border-radius: 8px;
  padding: 2rem;
  text-align: center;
  color: #666;
}

/* Upload Area Styling */
.upload-container {
  margin: 1.5rem 0;
}

.upload-area {
  border: 2px dashed var(--accent-color, #3498db);
  border-radius: 12px;
  padding: 2rem;
  transition: all 0.3s ease;
  background-color: rgba(52, 152, 219, 0.05);
  cursor: pointer;
}

.upload-area:hover {
  border-color: var(--primary-color, #2c3e50);
  background-color: rgba(52, 152, 219, 0.08);
}

.upload-area.drag-over {
  border-color: #2ecc71;
  background-color: rgba(46, 204, 113, 0.1);
  box-shadow: 0 0 15px rgba(46, 204, 113, 0.2);
}

.upload-content {
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.upload-icon-container {
  margin-bottom: 1.5rem;
  height: 120px;
  width: 120px;
  position: relative;
}

/* Folder Icon Animation */
.folder-icon {
  position: relative;
  width: 100%;
  height: 100%;
}

.folder-back {
  position: absolute;
  bottom: 10px;
  left: 0;
  right: 0;
  height: 70px;
  background-color: #f5ba1a;
  border-radius: 5px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  z-index: 1;
  transform-origin: bottom center;
  animation: folderWiggle 5s infinite ease-in-out;
}

.folder-front {
  position: absolute;
  bottom: 10px;
  left: 0;
  right: 0;
  height: 55px;
  background-color: #f5ba1a;
  border-radius: 5px 5px 0 0;
  z-index: 3;
}

.folder-front:before {
  content: '';
  position: absolute;
  top: -15px;
  left: 0;
  width: 40%;
  height: 15px;
  background-color: #f5ba1a;
  border-radius: 5px 5px 0 0;
}

.upload-arrow {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  color: #3498db;
  font-size: 24px;
  z-index: 4;
  animation: arrowBounce 2s infinite ease-in-out;
}

.file-icons {
  position: absolute;
  bottom: 23px;
  left: 15px;
  right: 15px;
  height: 40px;
  z-index: 2;
}

.file {
  position: absolute;
  width: 26px;
  height: 32px;
  background-color: #fff;
  border-radius: 3px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #555;
  animation: fileFloat 4s infinite ease-in-out;
}

.file1 {
  left: 10%;
  animation-delay: 0s;
}

.file2 {
  left: 50%;
  transform: translateX(-50%);
  animation-delay: 0.5s;
}

.file3 {
  right: 10%;
  animation-delay: 1s;
}

@keyframes folderWiggle {
  0%, 100% { transform: rotateZ(0); }
  25% { transform: rotateZ(-2deg); }
  75% { transform: rotateZ(2deg); }
}

@keyframes arrowBounce {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(-50%) translateY(-10px); }
}

@keyframes fileFloat {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}

.upload-title {
  margin: 0 0 0.5rem;
  color: var(--primary-color, #2c3e50);
  font-size: 1.4rem;
}

.upload-text {
  margin: 0 0 1rem;
  color: var(--text-color, #555);
  font-size: 1.1rem;
}

.upload-help-box {
  background-color: rgba(52, 152, 219, 0.1);
  padding: 0.75rem 1rem;
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.9rem;
  color: var(--light-text, #666);
  max-width: 500px;
  margin: 0 auto;
}

.uploaded-files {
  margin-top: 1.5rem;
  background-color: white;
  border-radius: 8px;
  padding: 1.5rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.uploaded-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.file-count, .file-analysis-count {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 500;
  color: var(--text-color, #333);
}

.file-types-summary {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
}

.file-type-badge {
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: bold;
  color: white;
}

.file-type-badge.javascript {
  background-color: #f7df1e;
  color: #333;
}

.file-type-badge.python {
  background-color: #306998;
}

.file-type-badge.java {
  background-color: #5382a1;
}

.file-type-badge.other {
  background-color: #8e44ad;
}

.file-actions {
  display: flex;
  gap: 1rem;
  justify-content: flex-end;
}

.progress-container {
  margin: 20px 0;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 15px;
  background-color: #f9f9f9;
}

.progress-bar-container {
  height: 20px;
  width: 100%;
  background-color: #eee;
  border-radius: 10px;
  position: relative;
  margin-bottom: 10px;
  overflow: hidden;
}

.progress-bar {
  height: 100%;
  background-color: #4CAF50;
  border-radius: 10px;
  transition: width 0.3s ease;
}

.progress-status {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  text-align: center;
  line-height: 20px;
  font-size: 12px;
  color: #fff;
  text-shadow: 0 0 2px rgba(0,0,0,0.5);
}

.progress-message {
  font-size: 14px;
  margin-bottom: 15px;
  padding: 5px;
  background-color: #fff;
  border-radius: 4px;
}

.progress-history {
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
  background-color: #fff;
}

.checkpoint-list {
  list-style-type: none;
  padding: 0;
  margin: 0;
}

.checkpoint {
  padding: 5px 10px;
  border-bottom: 1px solid #eee;
  font-size: 13px;
  display: flex;
  align-items: center;
}

.checkpoint:last-child {
  border-bottom: none;
}

.checkpoint-time {
  color: #999;
  margin-right: 10px;
  font-size: 11px;
  min-width: 70px;
}

.checkpoint-status {
  font-weight: bold;
  margin-right: 10px;
  padding: 2px 5px;
  border-radius: 3px;
  font-size: 11px;
  text-transform: uppercase;
  color: #fff;
  background-color: #999;
}

.checkpoint.starting .checkpoint-status,
.checkpoint.fetching_files .checkpoint-status,
.checkpoint.processing_files .checkpoint-status {
  background-color: #2196F3; /* Blue */
}

.checkpoint.fetching_vulnerabilities .checkpoint-status,
.checkpoint.repository_created .checkpoint-status {
  background-color: #FF9800; /* Orange */
}

.checkpoint.analyzing_code .checkpoint-status,
.checkpoint.evaluating .checkpoint-status {
  background-color: #9C27B0; /* Purple */
}

.checkpoint.completed .checkpoint-status {
  background-color: #4CAF50; /* Green */
}

.checkpoint.error .checkpoint-status {
  background-color: #F44336; /* Red */
}

.checkpoint-message {
  flex: 1;
}

/* Modern Tab Styling */
.tabs-container {
  display: flex;
  flex-direction: column;
  margin: 1rem 0 2rem;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  background-color: white;
  overflow: hidden;
}

.tabs-wrapper {
  display: flex;
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  border-bottom: 1px solid #e0e0e0;
}

.tab-item {
  flex: 1;
  position: relative;
  padding: 1.2rem 1rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  color: #666;
}

.tab-item:hover {
  background-color: rgba(52, 152, 219, 0.05);
  color: #3498db;
}

.tab-item.active {
  background-color: white;
  color: #3498db;
  font-weight: 600;
}

.tab-icon {
  font-size: 1.3rem;
  margin-bottom: 0.2rem;
}

.tab-label {
  font-size: 1rem;
}

.tab-indicator {
  position: absolute;
  bottom: 0;
  left: 10%;
  width: 80%;
  height: 3px;
  background-color: transparent;
  transition: background-color 0.3s ease;
  border-radius: 3px 3px 0 0;
}

.tab-item.active .tab-indicator {
  background-color: #3498db;
}

.tab-content {
  position: relative;
  overflow: hidden;
}

.tab-panel {
  padding: 1.5rem;
  display: none;
  opacity: 0;
  transform: translateY(10px);
  transition: all 0.5s ease;
}

.tab-panel.active {
  display: block;
  opacity: 1;
  transform: translateY(0);
  animation: fadeIn 0.5s ease forwards;
}

@keyframes fadeIn {
  0% {
    opacity: 0;
    transform: translateY(10px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Enhanced Select Styling */
.select-wrapper {
  position: relative;
  margin-bottom: 15px;
}

.select-wrapper::after {
  content: '\f078';  /* FontAwesome icon for chevron down */
  font-family: 'Font Awesome 5 Free';
  font-weight: 900;
  position: absolute;
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
  color: #3498db;
  pointer-events: none;
}

.enhanced-select {
  appearance: none;
  padding: 12px 40px 12px 15px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  background-color: white;
  width: 100%;
  font-size: 1rem;
  transition: border-color 0.3s, box-shadow 0.3s;
  cursor: pointer;
}

.enhanced-select:hover {
  border-color: #3498db;
}

.enhanced-select:focus {
  border-color: #3498db;
  outline: none;
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

.enhanced-select:disabled {
  background-color: #f8f9fa;
  color: #adb5bd;
  cursor: not-allowed;
}

/* Spinner Ring Animation */
.spinner-ring {
  display: inline-block;
  width: 60px;
  height: 60px;
  margin-bottom: 20px;
}

.spinner-ring:after {
  content: " ";
  display: block;
  width: 48px;
  height: 48px;
  margin: 6px;
  border-radius: 50%;
  border: 6px solid #3498db;
  border-color: #3498db transparent #3498db transparent;
  animation: spinner-ring 1.2s linear infinite;
}

@keyframes spinner-ring {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.loading-text {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  color: #555;
}

.loading-title {
  font-size: 1.2rem;
  font-weight: 600;
  margin-bottom: 8px;
  color: #333;
}

.loading-subtitle {
  font-size: 0.9rem;
  color: #777;
  max-width: 400px;
}

/* Error Container Styling */
.error-container {
  display: flex;
  padding: 20px;
  background-color: #fff3f3;
  border: 1px solid #ffcdd2;
  border-left: 5px solid #f44336;
  border-radius: 4px;
  margin: 1.5rem 0;
}

.error-icon {
  color: #f44336;
  font-size: 1.8rem;
  margin-right: 15px;
  display: flex;
  align-items: center;
}

.error-content {
  flex: 1;
}

.error-message {
  font-size: 1rem;
  color: #d32f2f;
  margin-bottom: 15px;
}
</style>

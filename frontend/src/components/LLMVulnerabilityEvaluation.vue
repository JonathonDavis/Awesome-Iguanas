<template>
  <div class="llm-vulnerability-evaluation">
    <h2><i class="fas fa-shield-alt"></i> LLM Vulnerability Analysis</h2>
    
    <div v-if="loading" class="loading-container">
      <div class="spinner-ring"></div>
      <p class="loading-text">
        <span class="loading-title">Analyzing with AI...</span>
        <span class="loading-subtitle">Scanning code patterns and identifying potential vulnerabilities</span>
      </p>
    </div>
    
    <div v-if="error" class="error-container">
      <div class="error-icon"><i class="fas fa-exclamation-triangle"></i></div>
      <div class="error-content">
        <p class="error-message">{{ error }}</p>
        <button @click="retryEvaluation" class="btn btn-primary">
          <i class="fas fa-redo"></i> Retry Analysis
        </button>
      </div>
    </div>
    
    <div class="analysis-tabs">
      <div 
        :class="['tab', { active: activeTab === 'upload' }]"
        @click="activeTab = 'upload'"
      >
        <i class="fas fa-upload"></i> Upload Repository
      </div>
      <div 
        :class="['tab', { active: activeTab === 'select' }]"
        @click="activeTab = 'select'"
      >
        <i class="fas fa-database"></i> Select Existing Repository
      </div>
    </div>
      <div v-if="activeTab === 'upload'" class="upload-container">
      <div 
        class="upload-area" 
        @dragover.prevent="onDragOver" 
        @drop.prevent="onDrop"
        @dragleave.prevent="event => event.target.classList.remove('drag-over')"
      >
        <input 
          type="file" 
          ref="fileInput" 
          @change="handleFileUpload" 
          webkitdirectory directory multiple
          style="display: none"
        />        <div class="upload-content" @click="triggerFileInput">
          <div class="upload-icon-container">
            <div class="folder-icon">
              <div class="folder-back"></div>
              <div class="folder-front"></div>
              <div class="upload-arrow">
                <i class="fas fa-arrow-down"></i>
              </div>
              <div class="file-icons">
                <div class="file file1"><i class="fas fa-code"></i></div>
                <div class="file file2"><i class="fas fa-file-code"></i></div>
                <div class="file file3"><i class="fas fa-file-alt"></i></div>
              </div>
            </div>
          </div>
          <h3 class="upload-title">Drag & Drop Repository</h3>
          <p class="upload-text">Drop your code folder here or click to browse</p>
          <div class="upload-help-box">
            <i class="fas fa-info-circle"></i>
            <span>For best results, upload a complete repository with source code files</span>
          </div>
        </div>
      </div>
      
      <div v-if="uploadedFiles.length > 0" class="uploaded-files">
        <div class="uploaded-header">
          <div class="file-count">
            <i class="fas fa-folder-open"></i>
            <span>{{ uploadedFiles.length }} files uploaded</span>
          </div>
          <div class="file-analysis-count">
            <i class="fas fa-code"></i>
            <span>{{ filteredFiles.length }} files will be analyzed</span>
          </div>
        </div>
        
        <div class="file-types-summary">
          <div class="file-type-badge javascript">JS</div>
          <div class="file-type-badge python">PY</div>
          <div class="file-type-badge java">JAVA</div>
          <div class="file-type-badge other">Other</div>
        </div>
        
        <div class="file-actions">
          <button @click="clearUpload" class="btn btn-secondary">
            <i class="fas fa-trash-alt"></i> Clear Files
          </button>
          <button @click="evaluateUploadedFiles" class="btn btn-primary">
            <i class="fas fa-search"></i> Analyze Code
          </button>
        </div>
      </div>
    </div>
      <div v-if="activeTab === 'select'" class="select-container">
      <div class="repository-selector">
        <div class="select-group">
          <label for="repository" class="select-label">
            <i class="fas fa-server"></i> Repository
          </label>
          <div class="select-wrapper">
            <select id="repository" v-model="selectedRepository" @change="onRepositoryChange" class="enhanced-select">
              <option v-for="repo in repositories" :key="repo.id" :value="repo">
                {{ repo.url }}
              </option>
            </select>
            <i class="fas fa-chevron-down select-arrow"></i>
          </div>
        </div>
          <div class="select-group">
          <label for="version" class="select-label">
            <i class="fas fa-code-branch"></i> Version
          </label>
          <div class="select-wrapper">
            <select id="version" v-model="selectedVersion" @change="onVersionChange" class="enhanced-select" :disabled="!versions.length">
              <option v-if="versions.length === 0" value="">No versions available</option>
              <option v-for="version in versions" :key="version.version" :value="version">
                {{ version.version }}
              </option>
            </select>
            <i class="fas fa-chevron-down select-arrow"></i>
          </div>
        </div>
        
        <button @click="evaluateRevision" class="btn btn-primary run-analysis-btn" :disabled="!selectedRepository">
          <i class="fas fa-brain"></i> Run LLM Analysis
        </button>
      </div>
      
      <div v-if="!selectedRepository && !loading && !error" class="empty-repo-state">
        <i class="fas fa-database"></i>
        <p>No repositories available. Please add repositories to the database first.</p>
      </div>
    </div>
      <div v-if="evaluationResults.length > 0" class="results-container">
      <div class="results-header">
        <h3><i class="fas fa-chart-pie"></i> Analysis Results</h3>
      </div>
      
      <div class="metrics-panel" v-if="metrics">
        <div class="metrics-header">
          <h4>Vulnerability Metrics</h4>
          <span class="metrics-subtitle">AI-powered vulnerability detection summary</span>
        </div>
        <div class="metrics-grid">
          <div class="metric total">
            <div class="metric-icon">
              <i class="fas fa-clipboard-check"></i>
            </div>
            <div class="metric-content">
              <p class="metric-value">{{ metrics.totalEvaluations }}</p>
              <p class="metric-label">Total Evaluations</p>
            </div>
          </div>
          <div class="metric high">
            <div class="metric-icon">
              <i class="fas fa-exclamation-circle"></i>
            </div>
            <div class="metric-content">
              <p class="metric-value">{{ metrics.classificationDistribution['very promising'] || 0 }}</p>
              <p class="metric-label">Very Promising</p>
            </div>
          </div>
          <div class="metric medium">
            <div class="metric-icon">
              <i class="fas fa-exclamation"></i>
            </div>
            <div class="metric-content">
              <p class="metric-value">{{ metrics.classificationDistribution['slightly promising'] || 0 }}</p>
              <p class="metric-label">Slightly Promising</p>
            </div>
          </div>
          <div class="metric low">
            <div class="metric-icon">
              <i class="fas fa-info-circle"></i>
            </div>
            <div class="metric-content">
              <p class="metric-value">{{ metrics.classificationDistribution['not promising'] || 0 }}</p>
              <p class="metric-label">Not Promising</p>
            </div>
          </div>
        </div>
      </div>
          <div class="vulnerability-filter">
        <div class="filter-label"><i class="fas fa-filter"></i> Filter:</div>
        <div class="filter-options">
          <button @click="setFilter('all')" :class="['filter-btn', {'active': selectedFilter === 'all'}]">All</button>
          <button @click="setFilter('very promising')" :class="['filter-btn very-promising', {'active': selectedFilter === 'very promising'}]">Very Promising</button>
          <button @click="setFilter('slightly promising')" :class="['filter-btn slightly-promising', {'active': selectedFilter === 'slightly promising'}]">Slightly Promising</button>
          <button @click="setFilter('not promising')" :class="['filter-btn not-promising', {'active': selectedFilter === 'not promising'}]">Not Promising</button>
        </div>
      </div>
          <div class="vulnerability-cards">
        <div 
          v-for="result in filteredEvaluationResults" 
          :key="result.vulnerabilityId" 
          :class="['vulnerability-card', `classification-${result.classification.replace(' ', '-')}`]"
        >
          <div class="card-indicator"></div>
          <div class="card-header">
            <div class="header-content">
              <h3>{{ result.headline }}</h3>
              <span :class="['classification-badge', result.classification.replace(' ', '-')]">
                <i class="classification-icon" 
                   :class="result.classification === 'very promising' ? 'fas fa-exclamation-circle' : 
                           result.classification === 'slightly promising' ? 'fas fa-exclamation' : 
                           'fas fa-info-circle'"></i>
                {{ result.classification }}
              </span>
            </div>
            <span class="vulnerability-id">ID: {{ result.vulnerabilityId }}</span>
          </div>
          
          <div class="card-content">
            <div class="analysis-section">
              <h4><i class="fas fa-search"></i> Analysis</h4>
              <p class="analysis">{{ result.analysis }}</p>
            </div>
            
            <div class="details-grid">
              <div class="detail-section">
                <h4><i class="fas fa-bug"></i> CVE Type</h4>
                <div class="detail-content">
                  <span class="cve-badge">{{ result.cve }}</span>
                </div>
              </div>
              
              <div class="detail-section">
                <h4><i class="fas fa-code"></i> Concerned Functions</h4>
                <div class="detail-content scrollable">
                  <ul class="function-list">
                    <li v-for="(func, idx) in result.concernedFunctions" :key="idx">
                      <i class="fas fa-function"></i> {{ func }}
                    </li>
                    <li v-if="result.concernedFunctions.length === 0" class="empty-list">No specific functions identified</li>
                  </ul>
                </div>
              </div>
              
              <div class="detail-section">
                <h4><i class="fas fa-file-code"></i> Concerned Files</h4>
                <div class="detail-content scrollable">
                  <ul class="file-list">
                    <li v-for="(file, idx) in result.concernedFiles" :key="idx">
                      <i class="fas fa-file"></i> {{ file }}
                    </li>
                    <li v-if="result.concernedFiles.length === 0" class="empty-list">No specific files identified</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>    <div v-else-if="!loading && selectedVersion" class="no-results">
      <div class="empty-state">
        <i class="fas fa-search"></i>
        <h3>No Vulnerabilities Found</h3>
        <p>No vulnerability evaluations are available for this selection. Run an LLM analysis to examine potential security issues.</p>
        <button @click="evaluateRevision" class="btn btn-primary" :disabled="loading">
          <i class="fas fa-brain"></i> Run Analysis Now
        </button>
      </div>
    </div>
  </div>
</template>

<script>
import neo4jService from '../services/neo4j/neo4jService';
import { LLMVulnerabilityEvaluator } from '../services/neo4j/llmVulnerabilityEvaluator';

export default {
  name: 'LLMVulnerabilityEvaluation',
  
  computed: {
    filteredEvaluationResults() {
      if (this.selectedFilter === 'all') {
        return this.evaluationResults;
      } else {
        return this.evaluationResults.filter(result => result.classification === this.selectedFilter);
      }
    }
  },
    data() {
    return {
      repositories: [],
      selectedRepository: null,
      versions: [],
      selectedVersion: null,
      evaluationResults: [],
      loading: false,
      error: null,
      neo4jService: null,
      llmEvaluator: null,
      metrics: null,
      activeTab: 'upload', // Default to the upload tab
      uploadedFiles: [],
      filteredFiles: [],
      selectedFilter: 'all', // Track the current filter selection
      // Extensions and paths to block in analysis
      blockedExtensions: [
        '.css', '.lock', '.md', '.min.js', '.scss', '.txt', '.rst', 
        '.json', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', 
        '.eot', '.ttf', '.woff', '.woff2', '.map', '.yaml', '.yml'
      ],
      maxFileSize: 200000 // 200,000 characters limit
    };
  },
    async created() {
    try {
      // Use the neo4j service singleton instance
      this.neo4jService = neo4jService;
      this.llmEvaluator = new LLMVulnerabilityEvaluator(this.neo4jService.driver);
      
      await this.loadRepositories();
      
      // Calculate metrics
      this.metrics = await this.llmEvaluator.calculateEvaluationMetrics();
    } catch (error) {
      this.error = `Failed to initialize: ${error.message}`;
    }
  },
  
  methods: {    async loadRepositories() {
      try {
        const session = this.neo4jService.driver.session();
        const result = await session.run(`
          MATCH (r:Repository)
          RETURN r.id AS id, r.url AS url, ID(r) AS nodeId
          ORDER BY r.url
        `);
        
        this.repositories = result.records.map(record => {
          const url = record.get('url');
          // Use the repository ID if available, otherwise use URL as a fallback ID
          // If neither is available, use the Neo4j internal node ID as a last resort
          const id = record.get('id') || url || `node-${record.get('nodeId')}`;
          
          console.log(`Repository: ${url}, ID: ${id}`);
          
          return {
            id: id,
            url: url
          };
        });
        
        if (this.repositories.length > 0) {
          this.selectedRepository = this.repositories[0];
          await this.onRepositoryChange();
        }
        
        await session.close();
      } catch (error) {
        this.error = `Failed to load repositories: ${error.message}`;
      }
    },
    async onRepositoryChange() {
      if (!this.selectedRepository) return;
      this.selectedVersion = null; // Reset selected version when repository changes
      this.evaluationResults = []; // Clear previous results
      
      try {
        const session = this.neo4jService.driver.session();
        const result = await session.run(`
          MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version)
          RETURN v.id AS id, v.version AS version
          ORDER BY v.version DESC
        `, { repoId: this.selectedRepository.id });
        
        this.versions = result.records.map(record => ({
          id: record.get('id'),
          version: record.get('version')
        }));
        
        console.log(`Loaded ${this.versions.length} versions for repository ${this.selectedRepository.url}`);
        
        if (this.versions.length > 0) {
          this.selectedVersion = this.versions[0];
          await this.onVersionChange();
        } else {
          console.warn('No versions found for selected repository');
          
          // Add a default "Latest" version option for repositories without versions
          this.versions = [{
            id: 'latest',
            version: 'Latest'
          }];
          this.selectedVersion = this.versions[0];
          
          // Enable direct repository analysis without requiring a specific version
          this.canRunAnalysis = true;
        }
        
        await session.close();
      } catch (error) {
        console.error('Error loading versions:', error);
        this.error = `Failed to load versions: ${error.message}`;
      }
    },    async onVersionChange() {
      if (!this.selectedRepository || !this.selectedVersion) return;
      
      try {
        this.loading = true;
        const session = this.neo4jService.driver.session();
        const result = await session.run(`
          MATCH (v:Version {id: $versionId})-[:HAS_EVALUATION]->(e:LLMEvaluation)-[:EVALUATES]->(vuln:Vulnerability)
          RETURN e.headline AS headline,
                 e.analysis AS analysis,
                 e.cve AS cve,
                 e.concernedFunctions AS concernedFunctions,
                 e.concernedFiles AS concernedFiles,
                 e.classification AS classification,
                 vuln.id AS vulnerabilityId
        `, { versionId: this.selectedVersion.id });
        
        this.evaluationResults = result.records.map(record => ({
          vulnerabilityId: record.get('vulnerabilityId'),
          headline: record.get('headline'),
          analysis: record.get('analysis'),
          cve: record.get('cve'),
          concernedFunctions: record.get('concernedFunctions') || [],
          concernedFiles: record.get('concernedFiles') || [],
          classification: record.get('classification') || 'not promising'
        }));
        
        await session.close();
      } catch (error) {
        this.error = `Failed to load evaluation results: ${error.message}`;
      } finally {
        this.loading = false;
      }
    },
    
    async loadRepositoryEvaluations(repositoryId) {
      try {
        this.loading = true;
        const session = this.neo4jService.driver.session();
        const result = await session.run(`
          MATCH (r:Repository {id: $repoId})-[:HAS_EVALUATION]->(e:LLMEvaluation)-[:EVALUATES]->(vuln:Vulnerability)
          RETURN e.headline AS headline,
                 e.analysis AS analysis,
                 e.cve AS cve,
                 e.concernedFunctions AS concernedFunctions,
                 e.concernedFiles AS concernedFiles,
                 e.classification AS classification,
                 vuln.id AS vulnerabilityId
        `, { repoId: repositoryId });
        
        this.evaluationResults = result.records.map(record => ({
          vulnerabilityId: record.get('vulnerabilityId'),
          headline: record.get('headline'),
          analysis: record.get('analysis'),
          cve: record.get('cve'),
          concernedFunctions: record.get('concernedFunctions') || [],
          concernedFiles: record.get('concernedFiles') || [],
          classification: record.get('classification') || 'not promising'
        }));
        
        await session.close();
      } catch (error) {
        this.error = `Failed to load repository evaluation results: ${error.message}`;
      } finally {
        this.loading = false;
      }
    },// File upload handling methods
    triggerFileInput() {
      this.$refs.fileInput.click();
    },
    
    onDragOver(event) {
      event.preventDefault();
      event.target.classList.add('drag-over');
    },
    
    onDrop(event) {
      event.preventDefault();
      event.target.classList.remove('drag-over');
      
      if (event.dataTransfer.items) {
        // Use DataTransferItemList interface to access the files
        this.processDroppedItems(event.dataTransfer.items);
      } else if (event.dataTransfer.files) {
        // Use DataTransfer interface to access the files
        this.handleFiles(Array.from(event.dataTransfer.files));
      }
    },
    
    processDroppedItems(items) {
      const files = [];
      
      const readEntries = async (entry, path = '') => {
        return new Promise(resolve => {
          if (entry.isFile) {
            entry.file(file => {
              file.relativePath = path + file.name;
              files.push(file);
              resolve();
            });
          } else if (entry.isDirectory) {
            const dirReader = entry.createReader();
            const readBatch = () => {
              dirReader.readEntries(entries => {
                if (entries.length > 0) {
                  Promise.all(entries.map(entry => {
                    return readEntries(entry, path + entry.name + '/');
                  })).then(() => {
                    readBatch();
                  });
                } else {
                  resolve();
                }
              });
            };
            readBatch();
          }
        });
      };
      
      const processItems = async () => {
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item.kind === 'file') {
            const entry = item.webkitGetAsEntry();
            if (entry) {
              await readEntries(entry);
            }
          }
        }
        this.handleFiles(files);
      };
      
      processItems();
    },
    
    handleFileUpload(event) {
      if (event.target.files) {
        this.handleFiles(Array.from(event.target.files));
      }
    },
    
    handleFiles(files) {
      this.uploadedFiles = files;
      this.filterFiles();
    },
      setFilter(filter) {
      // Update the selected filter
      this.selectedFilter = filter;
    },
    
    filterFiles() {
      // Apply filtering rules:
      // 1. Exclude files with blocklisted extensions
      // 2. Exclude files in paths starting with "."
      // 3. Exclude files larger than 200,000 characters
      // 4. Exclude files with non-text MIME types
      this.filteredFiles = this.uploadedFiles.filter(file => {
        // Check file extension
        const extension = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
        if (this.blockedExtensions.includes(extension)) return false;
        
        // Check path for dot files/directories
        if (file.relativePath) {
          const pathParts = file.relativePath.split('/');
          if (pathParts.some(part => part.startsWith('.'))) return false;
        }
        
        // Check file size - we'll do a rough conversion from bytes to characters
        // This is an approximation as the actual character count depends on encoding
        if (file.size > this.maxFileSize) return false;
        
        // Check MIME type - simple heuristic for text files
        if (!file.type.startsWith('text/') && 
            !file.name.match(/\.(js|ts|jsx|tsx|py|java|c|cpp|h|hpp|cs|rb|php|html|xml|go|rust|sol)$/i)) {
          // Try to identify code files not properly recognized by MIME type
          return false;
        }
        
        return true;
      });
    },
    
    clearUpload() {
      this.uploadedFiles = [];
      this.filteredFiles = [];
      this.$refs.fileInput.value = null;
    },
    
    async evaluateUploadedFiles() {
      if (this.filteredFiles.length === 0) {
        this.error = "No valid files to analyze. Please upload source code files.";
        return;
      }
      
      try {
        this.loading = true;
        this.error = null;
        const uploadedCodebase = [];
        
        // Read file contents and prepare for analysis
        for (const file of this.filteredFiles) {
          const content = await this.readFileContent(file);
          uploadedCodebase.push({
            path: file.relativePath || file.name,
            content: content,
            mimeType: file.type,
            size: file.size
          });
        }
        
        // Create a temporary repository ID for the uploaded codebase
        const temporaryRepoId = 'uploaded_' + Date.now();
        
        // Use custom method to evaluate the uploaded codebase
        const results = await this.evaluateUploadedCodebase(uploadedCodebase, temporaryRepoId);
        
        // Update the evaluation results
        this.evaluationResults = results;
        
      } catch (error) {
        this.error = `Failed to analyze uploaded files: ${error.message}`;
      } finally {
        this.loading = false;
      }
    },
    
    async readFileContent(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = (e) => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    },
    
    async evaluateUploadedCodebase(codeFiles, temporaryRepoId) {
      try {
        // Fetch common vulnerabilities that could be relevant
        const vulnerabilities = await this.getCommonVulnerabilities();
        const results = [];
        
        for (const vuln of vulnerabilities) {
          // Construct a prompt for the LLM to evaluate this vulnerability
          const prompt = this.constructLLMPrompt(codeFiles, vuln);
          
          // Call Ollama API directly for uploaded files (simplified flow)
          const response = await fetch(`${import.meta.env.VITE_OLLAMA_API_URL || 'http://localhost:11434'}/api/generate`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: import.meta.env.VITE_OLLAMA_MODEL || 'llama2:latest',
              prompt: prompt,
              stream: false
            })
          });
          
          if (!response.ok) {
            throw new Error(`Ollama API error: ${response.status}`);
          }
          
          const data = await response.json();
          
          // Parse the response to extract structured data
          const result = this.parseLLMResponse(data.response, vuln);
          results.push(result);
        }
        
        // Update metrics after evaluation
        await this.updateMetricsWithResults(results);
        
        return results;
      } catch (error) {
        console.error('Error evaluating uploaded codebase:', error);
        throw error;
      }
    },
    
    constructLLMPrompt(codeFiles, vulnerability) {
      // Include only the first 10 files to avoid token limits
      const MAX_FILES = 10;
      const selectedFiles = codeFiles.slice(0, MAX_FILES);
      
      // Format the code snippets
      const codeSnippets = selectedFiles.map(file => 
        `File: ${file.path}\n\`\`\`\n${file.content}\n\`\`\``
      ).join('\n\n');
      
      // Format CVE information
      const cveInfo = vulnerability.cveIds && vulnerability.cveIds.length > 0 
        ? vulnerability.cveIds.join(', ') 
        : 'No specific CVE';
      
      // Prepare the prompt
      return `You are a security expert analyzing code for potential vulnerabilities.
      
VULNERABILITY DETAILS:
ID: ${vulnerability.id}
Summary: ${vulnerability.summary || 'Not provided'}
Details: ${vulnerability.details || 'Not provided'}
CVE(s): ${cveInfo}

CODE TO ANALYZE:
${codeSnippets}

INSTRUCTIONS:
1. Analyze the code for the specified vulnerability.
2. Provide a concise headline for the vulnerability.
3. Write a detailed analysis of how the vulnerability affects this codebase.
4. Identify the most relevant CVE type for this vulnerability.
5. List the most concerned functions in the code (those most likely affected).
6. List the most concerned filenames in the codebase.
7. Classify the likelihood of this vulnerability being present as one of: "very promising", "slightly promising", or "not promising".

Format your response exactly like this:
HEADLINE: [Vulnerability headline]
ANALYSIS: [Detailed analysis]
RELEVANT_CVE: [Most relevant CVE type]
CONCERNED_FUNCTIONS: [List of functions, comma-separated]
CONCERNED_FILES: [List of filenames, comma-separated]
CLASSIFICATION: [very promising|slightly promising|not promising]

Be precise and concise. Base your classification strictly on the evidence in the code.`;
    },
    
    parseLLMResponse(response, vulnerability) {
      const result = {
        vulnerabilityId: vulnerability.id,
        headline: '',
        analysis: '',
        cve: '',
        concernedFunctions: [],
        concernedFiles: [],
        classification: 'not promising' // default
      };
      
      // Extract the headline
      const headlineMatch = response.match(/HEADLINE:\s*(.+?)(?=\n|ANALYSIS:)/s);
      if (headlineMatch) {
        result.headline = headlineMatch[1].trim();
      }
      
      // Extract the analysis
      const analysisMatch = response.match(/ANALYSIS:\s*(.+?)(?=\n|RELEVANT_CVE:)/s);
      if (analysisMatch) {
        result.analysis = analysisMatch[1].trim();
      }
      
      // Extract the CVE
      const cveMatch = response.match(/RELEVANT_CVE:\s*(.+?)(?=\n|CONCERNED_FUNCTIONS:)/s);
      if (cveMatch) {
        result.cve = cveMatch[1].trim();
      }
      
      // Extract concerned functions
      const functionsMatch = response.match(/CONCERNED_FUNCTIONS:\s*(.+?)(?=\n|CONCERNED_FILES:)/s);
      if (functionsMatch) {
        result.concernedFunctions = functionsMatch[1]
          .split(',')
          .map(func => func.trim())
          .filter(Boolean);
      }
      
      // Extract concerned files
      const filesMatch = response.match(/CONCERNED_FILES:\s*(.+?)(?=\n|CLASSIFICATION:)/s);
      if (filesMatch) {
        result.concernedFiles = filesMatch[1]
          .split(',')
          .map(file => file.trim())
          .filter(Boolean);
      }
      
      // Extract classification
      const classMatch = response.match(/CLASSIFICATION:\s*(.+?)(?=\n|$)/s);
      if (classMatch) {
        const classification = classMatch[1].trim().toLowerCase();
        if (["very promising", "slightly promising", "not promising"].includes(classification)) {
          result.classification = classification;
        }
      }
      
      return result;
    },
    
    async getCommonVulnerabilities() {
      // Get a list of common vulnerabilities to test against uploaded code
      const commonVulns = [
        {
          id: 'CWE-79',
          summary: 'Cross-site Scripting (XSS)',
          details: 'The software does not properly neutralize user-controllable input before it is placed in output that is used as a web page that is served to other users.',
          cveIds: ['CVE-2021-27889', 'CVE-2020-11022']
        },
        {
          id: 'CWE-89',
          summary: 'SQL Injection',
          details: 'The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize special elements that could modify the intended SQL command.',
          cveIds: ['CVE-2020-9480', 'CVE-2020-13937']
        },
        {
          id: 'CWE-20',
          summary: 'Improper Input Validation',
          details: 'The software does not validate or incorrectly validates input that can affect the control flow or data flow of a program.',
          cveIds: ['CVE-2021-21881', 'CVE-2021-1675']
        },
        {
          id: 'CWE-400',
          summary: 'Uncontrolled Resource Consumption',
          details: 'The software does not properly restrict the size or amount of resources that are requested or influenced by an actor, which can be used to consume more resources than intended.',
          cveIds: ['CVE-2020-8870', 'CVE-2019-1010266']
        },
        {
          id: 'CWE-200',
          summary: 'Information Exposure',
          details: 'The software exposes sensitive information to an actor that is not explicitly authorized to have access to that information.',
          cveIds: ['CVE-2021-21972', 'CVE-2020-28074']
        }
      ];
      
      return commonVulns;
    },
    
    async updateMetricsWithResults(results) {
      // Update metrics based on new evaluation results
      if (!this.metrics) {
        this.metrics = {
          totalEvaluations: 0,
          classificationDistribution: {
            'very promising': 0,
            'slightly promising': 0,
            'not promising': 0
          }
        };
      }
      
      // Update classification counts
      results.forEach(result => {
        this.metrics.totalEvaluations++;
        if (this.metrics.classificationDistribution.hasOwnProperty(result.classification)) {
          this.metrics.classificationDistribution[result.classification]++;
        }
      });
    },    async evaluateRevision() {
      if (!this.selectedRepository) {
        console.error("No repository selected");
        return;
      }
      
      try {
        this.loading = true;
        this.error = null;
        
        let result;
        
        // Check if we're using the special "latest" version ID for repositories without versions
        if (this.selectedVersion && this.selectedVersion.id === 'latest') {
          // Use direct repository evaluation without requiring a specific version
          console.log(`Evaluating repository directly: ${this.selectedRepository.url}`);
          console.log(`Repository ID: ${this.selectedRepository.id}, Type: ${typeof this.selectedRepository.id}`);
          
          // Ensure we have a valid repository ID
          if (!this.selectedRepository.id) {
            this.error = "Repository ID is missing. Please try selecting another repository.";
            this.loading = false;
            return;
          }
          
          // Get common vulnerabilities for testing since we don't have version-specific ones
          const commonVulnerabilities = await this.getCommonVulnerabilities();
          
          // Manually create code files representation
          const codeFiles = await this.llmEvaluator.getCodeFilesForRepository(
            String(this.selectedRepository.id) // Ensure ID is a string
          );
          
          console.log(`Found ${codeFiles.length} files in repository for analysis`);
          
          // If no code files were found, create a placeholder
          if (codeFiles.length === 0) {
            this.error = `No code files found in repository ${this.selectedRepository.url}. Please try another repository.`;
            this.loading = false;
            return;
          }
          
          // Evaluate each common vulnerability
          const evaluationResults = [];
          for (const vuln of commonVulnerabilities) {
            console.log(`Evaluating vulnerability ${vuln.id} for repository ${this.selectedRepository.url}`);
            const result = await this.llmEvaluator.evaluateVulnerabilityWithLLM(codeFiles, vuln);
            evaluationResults.push(result);
            
            // Store the evaluation result in the database
            await this.llmEvaluator.storeRepositoryEvaluationResult(this.selectedRepository.id, vuln.id, result);
          }
          
          // Set the evaluation results directly
          this.evaluationResults = evaluationResults;
          
        } else if (this.selectedVersion) {
          // Using a specific version
          console.log(`Evaluating repository with version: ${this.selectedRepository.url}, ${this.selectedVersion.version}`);
          result = await this.llmEvaluator.evaluateRevision(
            this.selectedRepository.id,
            this.selectedVersion.id
          );
          
          // Refresh the evaluation results for this specific version
          await this.onVersionChange();
        } else {
          throw new Error("No version selected for evaluation");
        }
        
        // Refresh metrics
        this.metrics = await this.llmEvaluator.calculateEvaluationMetrics();
      } catch (error) {
        this.error = `Failed to evaluate: ${error.message}`;
        console.error('Evaluation error:', error);
      } finally {
        this.loading = false;
      }
    },
    
    retryEvaluation() {
      this.error = null;
      this.evaluateRevision();
    }
  }
}
</script>

<style scoped>
.llm-vulnerability-evaluation {
  padding: 1rem;
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2rem;
}

.spinner {
  border: 4px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top: 4px solid #3498db;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin-bottom: 1rem;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error-container {
  background-color: #ffeeee;
  border: 1px solid #ff6666;
  border-radius: 4px;
  padding: 1rem;
  margin: 1rem 0;
}

.error-message {
  color: #cc0000;
  margin-bottom: 0.5rem;
}

.repository-selector {
  margin-bottom: 1.5rem;
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.repository-selector select {
  padding: 0.5rem;
  border-radius: 4px;
  border: 1px solid #ccc;
  min-width: 200px;
}

.btn {
  background-color: #4CAF50;
  color: white;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

.btn:hover {
  background-color: #45a049;
}

.btn:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.ml-4 {
  margin-left: 1rem;
}

.results-container {
  margin-top: 2rem;
}

.metrics-panel {
  background-color: #f5f5f5;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 2rem;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 1rem;
  margin-top: 1rem;
}

.metric {
  text-align: center;
  padding: 1rem;
  background-color: white;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.metric-value {
  font-size: 1.5rem;
  font-weight: bold;
  margin: 0;
}

.metric-label {
  margin: 0.5rem 0 0;
  color: #666;
}

.vulnerability-cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 1.5rem;
}

.vulnerability-card {
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  border-top: 5px solid #ccc;
}

.classification-very-promising {
  border-top-color: #4dff56;
}

.classification-slightly-promising {
  border-top-color: #ffa64d;
}

.classification-not-promising {
  border-top-color: #910a0a;
}

.card-header {
  padding: 1rem;
  background-color: #f8f8f8;
  border-bottom: 1px solid #eee;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-header h3 {
  margin: 0;
  font-size: 1.2rem;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.classification-badge {
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: bold;
  white-space: nowrap;
}

.classification-very-promising .classification-badge {
  background-color: #d2ffcc;
  color: #00cc1b;
}

.classification-slightly-promising .classification-badge {
  background-color: #ffe0b3;
  color: #cc7000;
}

.classification-not-promising .classification-badge {
  background-color: #ffcccc;
  color: #cc0000;
}

.card-content {
  padding: 1rem;
}

.analysis {
  line-height: 1.5;
  margin-bottom: 1.5rem;
  color: #333;
}

.detail-section {
  margin-bottom: 1rem;
}

.detail-section h4 {
  font-size: 1rem;
  margin-bottom: 0.5rem;
  color: #555;
}

.detail-section ul {
  list-style-type: disc;
  margin-left: 1.25rem;
  padding-left: 0;
}

.no-results {
  background-color: #f9f9f9;
  border-radius: 8px;
  padding: 2rem;
  text-align: center;
  color: #666;
}

/* Upload Area Styling */
.upload-container {
  margin: 1.5rem 0;
}

.upload-area {
  border: 2px dashed var(--accent-color, #3498db);
  border-radius: 12px;
  padding: 2rem;
  transition: all 0.3s ease;
  background-color: rgba(52, 152, 219, 0.05);
  cursor: pointer;
}

.upload-area:hover {
  border-color: var(--primary-color, #2c3e50);
  background-color: rgba(52, 152, 219, 0.08);
}

.upload-area.drag-over {
  border-color: #2ecc71;
  background-color: rgba(46, 204, 113, 0.1);
  box-shadow: 0 0 15px rgba(46, 204, 113, 0.2);
}

.upload-content {
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.upload-icon-container {
  margin-bottom: 1.5rem;
  height: 120px;
  width: 120px;
  position: relative;
}

/* Folder Icon Animation */
.folder-icon {
  position: relative;
  width: 100%;
  height: 100%;
}

.folder-back {
  position: absolute;
  bottom: 10px;
  left: 0;
  right: 0;
  height: 70px;
  background-color: #f5ba1a;
  border-radius: 5px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  z-index: 1;
  transform-origin: bottom center;
  animation: folderWiggle 5s infinite ease-in-out;
}

.folder-front {
  position: absolute;
  bottom: 10px;
  left: 0;
  right: 0;
  height: 55px;
  background-color: #f5ba1a;
  border-radius: 5px 5px 0 0;
  z-index: 3;
}

.folder-front:before {
  content: '';
  position: absolute;
  top: -15px;
  left: 0;
  width: 40%;
  height: 15px;
  background-color: #f5ba1a;
  border-radius: 5px 5px 0 0;
}

.upload-arrow {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  color: #3498db;
  font-size: 24px;
  z-index: 4;
  animation: arrowBounce 2s infinite ease-in-out;
}

.file-icons {
  position: absolute;
  bottom: 23px;
  left: 15px;
  right: 15px;
  height: 40px;
  z-index: 2;
}

.file {
  position: absolute;
  width: 26px;
  height: 32px;
  background-color: #fff;
  border-radius: 3px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #555;
  animation: fileFloat 4s infinite ease-in-out;
}

.file1 {
  left: 10%;
  animation-delay: 0s;
}

.file2 {
  left: 50%;
  transform: translateX(-50%);
  animation-delay: 0.5s;
}

.file3 {
  right: 10%;
  animation-delay: 1s;
}

@keyframes folderWiggle {
  0%, 100% { transform: rotateZ(0); }
  25% { transform: rotateZ(-2deg); }
  75% { transform: rotateZ(2deg); }
}

@keyframes arrowBounce {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(-50%) translateY(-10px); }
}

@keyframes fileFloat {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}

.upload-title {
  margin: 0 0 0.5rem;
  color: var(--primary-color, #2c3e50);
  font-size: 1.4rem;
}

.upload-text {
  margin: 0 0 1rem;
  color: var(--text-color, #555);
  font-size: 1.1rem;
}

.upload-help-box {
  background-color: rgba(52, 152, 219, 0.1);
  padding: 0.75rem 1rem;
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.9rem;
  color: var(--light-text, #666);
  max-width: 500px;
  margin: 0 auto;
}

.uploaded-files {
  margin-top: 1.5rem;
  background-color: white;
  border-radius: 8px;
  padding: 1.5rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.uploaded-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.file-count, .file-analysis-count {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 500;
  color: var(--text-color, #333);
}

.file-types-summary {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
}

.file-type-badge {
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: bold;
  color: white;
}

.file-type-badge.javascript {
  background-color: #f7df1e;
  color: #333;
}

.file-type-badge.python {
  background-color: #306998;
}

.file-type-badge.java {
  background-color: #5382a1;
}

.file-type-badge.other {
  background-color: #8e44ad;
}

.file-actions {
  display: flex;
  gap: 1rem;
  justify-content: flex-end;
}
</style>

export function processVulnerability(vuln) {
  return {
    id: vuln.id,
    schema_version: vuln.schema_version || '',
    modified: vuln.modified || new Date().toISOString(),
    published: vuln.published || new Date().toISOString(),
    withdrawn: vuln.withdrawn || null,
    aliases: vuln.aliases || [],
    upstream: vuln.upstream || [],
    related: vuln.related || [],
    summary: vuln.summary || '',
    details: vuln.details || '',
    severity: extractSeverity(vuln),
    severity_details: vuln.severity || [],
    affected: vuln.affected || [],
    references: vuln.references || [],
    credits: vuln.credits || [],
    database_specific: vuln.database_specific || {}
  };
}

function extractSeverity(vuln) {
  if (!vuln.severity || vuln.severity.length === 0) {
    return 'UNKNOWN';
  }
  
  // Try to find a CVSS score
  for (const sev of vuln.severity) {
    if (sev.type === 'CVSS_V3' && sev.score) {
      const score = parseFloat(sev.score);
      if (!isNaN(score)) {
        if (score >= 9.0) return 'CRITICAL';
        if (score >= 7.0) return 'HIGH';
        if (score >= 4.0) return 'MEDIUM';
        if (score >= 0.1) return 'LOW';
      }
    }
  }
  
  return 'UNKNOWN';
}

export async function storeVulnerability(vulnerability) {
  if (!vulnerability) return;
  
  const session = this.driver.session();
  try {
    // Create vulnerability node with all fields
    await session.run(`
      MERGE (v:Vulnerability {id: $id})
      ON CREATE SET 
        v.schema_version = $schema_version,
        v.summary = $summary,
        v.details = $details,
        v.severity = $severity,
        v.published = datetime($published),
        v.modified = datetime($modified),
        v.withdrawn = CASE WHEN $withdrawn IS NOT NULL THEN datetime($withdrawn) ELSE null END,
        v.aliases = $aliases,
        v.upstream = $upstream,
        v.related = $related,
        v.severity_details = $severity_details,
        v.references = $references,
        v.credits = $credits,
        v.database_specific = $database_specific,
        v.created_at = datetime()
      ON MATCH SET 
        v.schema_version = $schema_version,
        v.summary = $summary,
        v.details = $details,
        v.severity = $severity,
        v.modified = datetime($modified),
        v.withdrawn = CASE WHEN $withdrawn IS NOT NULL THEN datetime($withdrawn) ELSE null END,
        v.aliases = $aliases,
        v.upstream = $upstream,
        v.related = $related,
        v.severity_details = $severity_details,
        v.references = $references,
        v.credits = $credits,
        v.database_specific = $database_specific,
        v.updated_at = datetime()
    `, {
      id: vulnerability.id,
      schema_version: vulnerability.schema_version,
      summary: vulnerability.summary,
      details: vulnerability.details,
      severity: vulnerability.severity,
      published: vulnerability.published,
      modified: vulnerability.modified,
      withdrawn: vulnerability.withdrawn,
      aliases: vulnerability.aliases,
      upstream: vulnerability.upstream,
      related: vulnerability.related,
      severity_details: vulnerability.severity_details,
      references: vulnerability.references,
      credits: vulnerability.credits,
      database_specific: vulnerability.database_specific
    });
    
    // Create package nodes and relationships with all affected package details
    for (const affected of vulnerability.affected) {
      const pkg = affected.package || {};
      const pkgName = pkg.name || 'unknown';
      const ecosystem = pkg.ecosystem || 'unknown';
      const purl = pkg.purl || null;
      
      // Create package node with additional details
      await session.run(`
        MERGE (p:Package {name: $name, ecosystem: $ecosystem})
        ON CREATE SET 
          p.purl = $purl,
          p.created_at = datetime()
        ON MATCH SET 
          p.purl = $purl,
          p.updated_at = datetime()
        WITH p
        MATCH (v:Vulnerability {id: $vulnId})
        MERGE (v)-[r:AFFECTS]->(p)
        ON CREATE SET 
          r.severity = $affected_severity,
          r.ranges = $ranges,
          r.versions = $versions,
          r.ecosystem_specific = $ecosystem_specific,
          r.database_specific = $database_specific,
          r.created_at = datetime()
        ON MATCH SET 
          r.severity = $affected_severity,
          r.ranges = $ranges,
          r.versions = $versions,
          r.ecosystem_specific = $ecosystem_specific,
          r.database_specific = $database_specific,
          r.updated_at = datetime()
      `, {
        name: pkgName,
        ecosystem: ecosystem,
        purl: purl,
        vulnId: vulnerability.id,
        affected_severity: affected.severity || [],
        ranges: affected.ranges || [],
        versions: affected.versions || [],
        ecosystem_specific: affected.ecosystem_specific || {},
        database_specific: affected.database_specific || {}
      });
    }
  } catch (error) {
    console.error('Error storing vulnerability in Neo4j:', error);
  } finally {
    await session.close();
  }
} 
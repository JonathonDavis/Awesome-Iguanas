import { apiClient } from './axiosConfig';

export class LLMVulnerabilityEvaluator {
  constructor(driver) {
    this.driver = driver;
    this.ollamaApiUrl = import.meta.env.VITE_OLLAMA_API_URL || import.meta.env.PRODUCTION.VITE_OLLAMA_API_URL || 'http://127.0.0.1:11434';
    this.ollamaModel = import.meta.env.VITE_OLLAMA_MODEL;
    
    // Blocklisted extensions and paths for files to exclude from analysis
    this.blockedExtensions = [
      '.css', '.lock', '.md', '.min.js', '.scss', '.txt', '.rst', 
      '.json', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', 
      '.eot', '.ttf', '.woff', '.woff2', '.map', '.yaml', '.yml'
    ];
    
    this.maxFileSize = 200000; // 200,000 characters limit for files
    
    // Allowed extensions for GitHub API file fetching
    this.allowedExtensions = ['.js', '.py', '.java', '.c', '.cpp', '.h', '.hpp', '.cs', '.rb', '.php', '.ts', '.go', '.rs'];
  }
  
  /**
   * Evaluates a repository revision for vulnerabilities using LLM
   * @param {string} repoId - The ID of the repository to evaluate
   * @param {string} versionId - The specific version/revision to evaluate
   * @returns {Promise<object>} - The evaluation results
   */
  async evaluateRevision(repoId, versionId) {
    try {
      // Create a progress tracking object
      const progress = {
        status: 'starting',
        message: 'Initializing evaluation',
        completed: 0,
        total: 0,
        timestamp: new Date().toISOString()
      };
      
      // Emit progress update (can be consumed by UI)
      this.emitProgress(repoId, progress);
      
      // 1. Fetch the code files for this revision
      progress.status = 'fetching_files';
      progress.message = 'Fetching code files for analysis';
      this.emitProgress(repoId, progress);
      
      const codeFiles = await this.getCodeFilesForRevision(repoId, versionId);
      
      // 2. Get relevant CVEs/CWEs for this codebase
      progress.status = 'fetching_vulnerabilities';
      progress.message = 'Identifying relevant vulnerabilities';
      this.emitProgress(repoId, progress);
      
      const vulnerabilities = await this.getRelevantVulnerabilities(repoId, versionId);
      
      // 3. For each vulnerability, run the LLM evaluation
      const evaluationResults = [];
      
      // Update progress with total vulnerabilities to process
      progress.status = 'evaluating';
      progress.total = vulnerabilities.length;
      progress.completed = 0;
      progress.message = `Evaluating 0/${vulnerabilities.length} vulnerabilities`;
      this.emitProgress(repoId, progress);
      
      for (const [index, vuln] of vulnerabilities.entries()) {
        // Update progress for current vulnerability
        progress.completed = index;
        progress.message = `Evaluating vulnerability ${index + 1}/${vulnerabilities.length}: ${vuln.id}`;
        this.emitProgress(repoId, progress);
        
        const result = await this.evaluateVulnerabilityWithLLM(codeFiles, vuln);
        evaluationResults.push(result);
        
        // Store the evaluation result in the database
        await this.storeEvaluationResult(repoId, versionId, vuln.id, result);
      }
      
      // Mark completion
      progress.status = 'completed';
      progress.completed = vulnerabilities.length;
      progress.message = `Completed evaluation of ${vulnerabilities.length} vulnerabilities`;
      this.emitProgress(repoId, progress);
      
      return {
        repositoryId: repoId,
        versionId: versionId,
        evaluationResults
      };
    } catch (error) {
      // Mark error in progress
      const errorProgress = {
        status: 'error',
        message: `Error: ${error.message}`,
        timestamp: new Date().toISOString()
      };
      this.emitProgress(repoId, errorProgress);
      
      console.error('Error evaluating revision:', error);
      throw error;
    }
  }
  
  /**
   * Evaluates a repository for vulnerabilities using LLM without requiring a specific version
   * @param {string} repoId - The ID of the repository to evaluate
   * @returns {Promise<object>} - The evaluation results
   */
  async evaluateRepository(repoId) {
    try {
      // Create a progress tracking object
      const progress = {
        status: 'starting',
        message: 'Initializing repository evaluation',
        completed: 0,
        total: 0,
        timestamp: new Date().toISOString()
      };
      
      // Emit progress update
      this.emitProgress(repoId, progress);
      
      // 1. Fetch the code files for this repository directly
      progress.status = 'fetching_files';
      progress.message = 'Fetching repository code files';
      this.emitProgress(repoId, progress);
      
      const codeFiles = await this.getCodeFilesForRepository(repoId);
      
      // Log file count
      console.log(`Retrieved ${codeFiles.length} code files for analysis`);
      progress.message = `Retrieved ${codeFiles.length} code files for analysis`;
      this.emitProgress(repoId, progress);
      
      // 2. Get relevant CVEs/CWEs for this codebase
      progress.status = 'fetching_vulnerabilities';
      progress.message = 'Identifying relevant vulnerabilities';
      this.emitProgress(repoId, progress);
      
      const vulnerabilities = await this.getRelevantVulnerabilitiesForRepo(repoId);
      
      console.log(`Found ${vulnerabilities.length} relevant vulnerabilities to evaluate`);
      
      // 3. For each vulnerability, run the LLM evaluation
      const evaluationResults = [];
      
      // Update progress with total vulnerabilities to process
      progress.status = 'evaluating';
      progress.total = vulnerabilities.length;
      progress.completed = 0;
      progress.message = `Starting evaluation of ${vulnerabilities.length} vulnerabilities`;
      this.emitProgress(repoId, progress);
      
      for (const [index, vuln] of vulnerabilities.entries()) {
        // Update progress for current vulnerability
        progress.completed = index;
        progress.message = `Evaluating vulnerability ${index + 1}/${vulnerabilities.length}: ${vuln.id}`;
        this.emitProgress(repoId, progress);
        
        const result = await this.evaluateVulnerabilityWithLLM(codeFiles, vuln);
        evaluationResults.push(result);
        
        // Store the evaluation result in the database directly on the repository
        await this.storeRepositoryEvaluationResult(repoId, vuln.id, result);
        
        // Update progress after completion of each vulnerability
        progress.message = `Completed ${index + 1}/${vulnerabilities.length} vulnerabilities`;
        this.emitProgress(repoId, progress);
      }
      
      // Mark completion
      progress.status = 'completed';
      progress.completed = vulnerabilities.length;
      progress.message = `Completed evaluation of ${vulnerabilities.length} vulnerabilities`;
      this.emitProgress(repoId, progress);
      
      return {
        repositoryId: repoId,
        evaluationResults
      };
    } catch (error) {
      // Mark error in progress
      const errorProgress = {
        status: 'error',
        message: `Error: ${error.message}`,
        timestamp: new Date().toISOString()
      };
      this.emitProgress(repoId, errorProgress);
      
      console.error('Error evaluating repository:', error);
      throw error;
    }
  }
  
  /**
   * Fetches code files for a specific repository revision
   * Applies filtering rules based on requirements
   */  
  async getCodeFilesForRevision(repoId, versionId) {
    const session = this.driver.session();
    try {
      const result = await session.run(`
        MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version {id: $versionId})-[:CONTAINS]->(f:File)
        RETURN f.path AS path, f.content AS content, f.mime_type AS mimeType, f.size AS size
      `, {
        repoId,
        versionId
      });
      
      return this.filterCodeFiles(result.records.map(record => ({
        path: record.get('path'),
        content: record.get('content'),
        mimeType: record.get('mimeType'),
        size: record.get('size')
      })));
    } finally {
      await session.close();
    }
  }
  
  /**
   * Fetches code files for a repository (without specifying version)
   * Applies filtering rules based on requirements
   */  
  async getCodeFilesForRepository(repoId) {
    // Validate the repository ID before proceeding
    if (!repoId) {
      console.error('Repository ID is null or undefined in getCodeFilesForRepository');
      return [];
    }

    console.log(`Starting code file retrieval for repository ID: ${repoId}`);
    
    // First, try to get files from Neo4j
    const session = this.driver.session();
    try {
      // Try multiple relationship patterns to find files
      // This handles different database schemas that might exist
      const result = await session.run(`
        // Try direct relationship
        MATCH (r:Repository {id: $repoId})-[:CONTAINS]->(f:File)
        RETURN f.path AS path, f.content AS content, f.mime_type AS mimeType, f.size AS size
        
        UNION
        
        // Try through versions
        MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version)-[:CONTAINS]->(f:File)
        RETURN f.path AS path, f.content AS content, f.mime_type AS mimeType, f.size AS size
        
        UNION
        
        // Try direct file content if stored on repository
        MATCH (r:Repository {id: $repoId})
        WHERE r.files IS NOT NULL
        UNWIND r.files AS file
        RETURN file.path AS path, file.content AS content, file.mime_type AS mimeType, file.size AS size
      `, {
        repoId
      });
      
      const files = result.records.map(record => ({
        path: record.get('path'),
        content: record.get('content'),
        mimeType: record.get('mimeType'),
        size: record.get('size')
      }));
      
      console.log(`Found ${files.length} total files for repository ${repoId} (before filtering)`);
      
      // If we found files in Neo4j, filter and return them
      if (files.length > 0) {
        return this.filterCodeFiles(files);
      }
      
      // If no files were found in Neo4j, and the ID looks like a GitHub URL, try fetching directly from GitHub
      if (repoId.includes('github.com')) {
        console.log(`No files found in Neo4j for ${repoId}, attempting to fetch from GitHub...`);
        const githubFiles = await this.fetchFilesFromGitHub(repoId);
        return this.filterCodeFiles(githubFiles);
      }
      
      // If we still don't have files, return an empty array
      return [];
    } catch (error) {
      console.error(`Error retrieving files for repository ${repoId}:`, error);
      
      // If there was an error with Neo4j query but the ID looks like a GitHub URL,
      // try fetching from GitHub as a fallback
      if (repoId.includes('github.com')) {
        console.log(`Error retrieving from Neo4j for ${repoId}, trying GitHub instead...`);
        try {
          const githubFiles = await this.fetchFilesFromGitHub(repoId);
          return this.filterCodeFiles(githubFiles);
        } catch (githubError) {
          console.error(`Failed to fetch from GitHub as well:`, githubError);
        }
      }
      
      return [];
    } finally {
      await session.close();
    }
  }
  
  /**
   * Fetches code files directly from GitHub API when they're not available in Neo4j
   * @param {string} repoUrl - The GitHub repository URL
   * @returns {Promise<Array>} - Array of code files
   */
  async fetchFilesFromGitHub(repoUrl) {
    try {
        // Extract owner and repo from URL
        const urlParts = repoUrl.split('/');
        if (urlParts.length < 5) {
            console.error('Invalid GitHub URL format:', repoUrl);
            return [];
        }

        const owner = urlParts[3];
        const repo = urlParts[4];

        console.log(`Attempting to fetch files directly from GitHub for ${owner}/${repo}`);

        // Include GitHub token in headers
        const githubToken = import.meta.env.VITE_GITHUB_TOKEN;
        const headers = githubToken ? { Authorization: `token ${githubToken}` } : {};

        // Recursive function to fetch files from a directory
        const fetchDirectoryContents = async (path = '') => {
            console.log(`Fetching directory: ${path || 'root'}`);
            const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, { headers });

            if (!response.ok) {
                console.error(`GitHub API error: ${response.status} for path: ${path}`);
                return [];
            }

            const contents = await response.json();
            const files = [];

            for (const item of contents) {
                console.log(`Processing item: ${item.name} (${item.type})`);
                if (item.type === 'file') {
                    // Check file extension
                    const extension = item.name.substring(item.name.lastIndexOf('.')).toLowerCase();
                    if (this.allowedExtensions.includes(extension) && !this.blockedExtensions.includes(extension)) {
                        try {
                            console.log(`Fetching file: ${item.path}`);
                            const fileResponse = await fetch(item.url, { headers });
                            if (fileResponse.ok) {
                                const fileData = await fileResponse.json();
                                const content = atob(fileData.content); // Decode base64 content

                                files.push({
                                    path: item.path,
                                    content: content,
                                    mimeType: 'text/plain',
                                    size: content.length
                                });
                                console.log(`Successfully fetched file: ${item.path}`);
                            }
                        } catch (error) {
                            console.error(`Error fetching file ${item.path}:`, error);
                        }
                    } else {
                        console.log(`Skipping file due to extension: ${item.name}`);
                    }
                } else if (item.type === 'dir') {
                    // Recursively fetch files from subdirectories
                    console.log(`Entering subdirectory: ${item.path}`);
                    const subdirectoryFiles = await fetchDirectoryContents(item.path);
                    files.push(...subdirectoryFiles);
                }
            }

            return files;
        };

        // Start fetching from the root directory
        const codeFiles = await fetchDirectoryContents();
        console.log(`Found ${codeFiles.length} code files from GitHub API`);
        return codeFiles;
    } catch (error) {
        console.error('Error fetching from GitHub:', error);
        return [];
    }
}
  
  /**
   * Common method to filter code files based on rules
   */
  filterCodeFiles(files) {
    // Apply filtering rules:
    // 1. Exclude files with blocklisted extensions
    // 2. Exclude files in paths starting with "."
    // 3. Exclude files larger than 200,000 characters
    // 4. Exclude files with non-text MIME types
    return files.filter(file => {
      if (!file.path) return false;
      
      // Check file extension
      const extension = file.path.substring(file.path.lastIndexOf('.')).toLowerCase();
      if (this.blockedExtensions.includes(extension)) return false;
      
      // Check path for dot files/directories
      const pathParts = file.path.split('/');
      if (pathParts.some(part => part.startsWith('.'))) return false;
      
      // Check file size
      if (file.content && file.content.length > this.maxFileSize) return false;
      
      // Check MIME type
      if (file.mimeType && !file.mimeType.startsWith('text/')) {
        // Try to identify code files not properly recognized by MIME type
        if (!file.path.match(/\.(js|ts|jsx|tsx|py|java|c|cpp|h|hpp|cs|rb|php|html|xml|go|rust|sol)$/i)) {
          return false;
        }
      }
      
      return true;
    });
  }
  
  /**
   * Gets relevant vulnerabilities for a repository version
   */
  async getRelevantVulnerabilities(repoId, versionId) {
    const session = this.driver.session();
    try {
      const result = await session.run(`
        MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version {id: $versionId})
        MATCH (v)-[:USES_PACKAGE]->(p:Package)<-[:AFFECTS]-(vuln:Vulnerability)
        OPTIONAL MATCH (c:CVE)-[:IDENTIFIED_AS]->(vuln)
        RETURN vuln, collect(DISTINCT c.id) AS cveIds
      `, {
        repoId,
        versionId
      });
      
      return result.records.map(record => {
        const vuln = record.get('vuln').properties;
        return {
          ...vuln,
          cveIds: record.get('cveIds')
        };
      });
    } finally {
      await session.close();
    }
  }
  
  /**
   * Gets relevant vulnerabilities for a repository without needing a specific version
   */
  async getRelevantVulnerabilitiesForRepo(repoId) {
    const session = this.driver.session();
    try {
      // First try to get package-specific vulnerabilities
      const result = await session.run(`
        MATCH (r:Repository {id: $repoId})-[:USES_PACKAGE]->(p:Package)<-[:AFFECTS]-(vuln:Vulnerability)
        OPTIONAL MATCH (c:CVE)-[:IDENTIFIED_AS]->(vuln)
        RETURN vuln, collect(DISTINCT c.id) AS cveIds
      `, {
        repoId
      });
      
      // If no specific vulnerabilities are found, get all vulnerabilities from the database
      if (result.records.length === 0) {
        const allVulnResult = await session.run(`
          MATCH (vuln:Vulnerability)
          OPTIONAL MATCH (c:CVE)-[:IDENTIFIED_AS]->(vuln)
          RETURN vuln, collect(DISTINCT c.id) AS cveIds
          
        `);
        
        if (allVulnResult.records.length === 0) {
          // Fallback to emergency common vulnerabilities only if database is completely empty
          return await this.getEmergencyCommonVulnerabilities();
        }
        
        return allVulnResult.records.map(record => {
          const vuln = record.get('vuln').properties;
          return {
            ...vuln,
            cveIds: record.get('cveIds')
          };
        });
      }
      
      return result.records.map(record => {
        const vuln = record.get('vuln').properties;
        return {
          ...vuln,
          cveIds: record.get('cveIds')
        };
      });
    } finally {
      await session.close();
    }
  }

  /**
   * Returns emergency common vulnerability types for evaluation when none are found in the database
   * Attempts to get data from Neo4j first, falls back to hardcoded entries only as a last resort
   */
  async getEmergencyCommonVulnerabilities() {
    const session = this.driver.session();
    try {
      // Try to fetch some vulnerabilities from Neo4j directly
      const result = await session.run(`
        MATCH (vuln:Vulnerability)
        OPTIONAL MATCH (c:CVE)-[:IDENTIFIED_AS]->(vuln)
        WITH vuln, collect(DISTINCT c.id) AS cveIds
        RETURN vuln, cveIds
        LIMIT 5
      `);

      // If we found some vulnerabilities, use them
      if (result.records.length > 0) {
        return result.records.map(record => {
          const vuln = record.get('vuln').properties;
          return {
            ...vuln,
            cveIds: record.get('cveIds')
          };
        });
      }

      // If we still don't have vulnerabilities, use a hardcoded fallback
      console.warn('No vulnerabilities found in the database, using emergency hardcoded fallback');
      return [
        {
          id: 'CWE-79',
          summary: 'Cross-site Scripting (XSS)',
          details: 'The software does not properly neutralize user-controllable input before it is placed in output that is used as a web page that is served to other users.',
          cveIds: ['CVE-2021-27889', 'CVE-2020-11022']
        },
        {
          id: 'CWE-89',
          summary: 'SQL Injection',
          details: 'The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize special elements that could modify the intended SQL command.',
          cveIds: ['CVE-2020-9480', 'CVE-2020-13937']
        },
        {
          id: 'CWE-20',
          summary: 'Improper Input Validation',
          details: 'The software does not validate or incorrectly validates input that can affect the control flow or data flow of a program.',
          cveIds: ['CVE-2021-21881', 'CVE-2021-1675']
        },
        {
          id: 'CWE-400',
          summary: 'Uncontrolled Resource Consumption',
          details: 'The software does not properly restrict the size or amount of resources that are requested or influenced by an actor, which can be used to consume more resources than intended.',
          cveIds: ['CVE-2020-8870', 'CVE-2019-1010266']
        },
        {
          id: 'CWE-200',
          summary: 'Information Exposure',
          details: 'The software exposes sensitive information to an actor that is not explicitly authorized to have access to that information.',
          cveIds: ['CVE-2021-21972', 'CVE-2020-28074']
        }
      ];
    } finally {
      await session.close();
    }
  }

  /**
   * Evaluates a vulnerability against codebase using LLM
   */
  async evaluateVulnerabilityWithLLM(codeFiles, vulnerability) {
    try {
      // Construct the prompt for the LLM
      const prompt = this.constructLLMPrompt(codeFiles, vulnerability);
      
      // Get environment variables directly to ensure consistency with upload functionality
      const ollamaModel = import.meta.env.VITE_OLLAMA_MODEL;
      
      // Use the proxy path instead of direct Ollama API URL to avoid CORS issues
      const response = await fetch(`/ollama-api/api/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: ollamaModel,
          prompt: prompt,
          stream: false
        })
      });
      
      if (!response.ok) {
        throw new Error(`Ollama API error: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Parse the response to extract structured data
      return this.parseLLMResponse(data.response, vulnerability);
    } catch (error) {
      console.error('Error calling LLM:', error);
      return {
        vulnerabilityId: vulnerability.id,
        headline: 'Error during evaluation',
        analysis: `Failed to evaluate: ${error.message}`,
        cve: vulnerability.cveIds?.[0] || 'Unknown',
        concernedFunctions: [],
        concernedFiles: [],
        classification: 'not promising',
        error: error.message
      };
    }
  }
  
  /**
   * Returns common vulnerability types for evaluation when none are found in the database
   */
  getCommonVulnerabilities() {
    // Get a list of common vulnerabilities to test against code
    return [
      {
        id: 'CWE-79',
        summary: 'Cross-site Scripting (XSS)',
        details: 'The software does not properly neutralize user-controllable input before it is placed in output that is used as a web page that is served to other users.',
        cveIds: ['CVE-2021-27889', 'CVE-2020-11022']
      },
      {
        id: 'CWE-89',
        summary: 'SQL Injection',
        details: 'The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize special elements that could modify the intended SQL command.',
        cveIds: ['CVE-2020-9480', 'CVE-2020-13937']
      },
      {
        id: 'CWE-20',
        summary: 'Improper Input Validation',
        details: 'The software does not validate or incorrectly validates input that can affect the control flow or data flow of a program.',
        cveIds: ['CVE-2021-21881', 'CVE-2021-1675']
      },
      {
        id: 'CWE-400',
        summary: 'Uncontrolled Resource Consumption',
        details: 'The software does not properly restrict the size or amount of resources that are requested or influenced by an actor, which can be used to consume more resources than intended.',
        cveIds: ['CVE-2020-8870', 'CVE-2019-1010266']
      },
      {
        id: 'CWE-200',
        summary: 'Information Exposure',
        details: 'The software exposes sensitive information to an actor that is not explicitly authorized to have access to that information.',
        cveIds: ['CVE-2021-21972', 'CVE-2020-28074']
      }
    ];
  }
  
  /**
   * Constructs a prompt for the LLM based on the codebase and vulnerability
   */
  constructLLMPrompt(codeFiles, vulnerability) {
    // Include only the first N files to avoid token limits
    const MAX_FILES = 10;
    const selectedFiles = codeFiles.slice(0, MAX_FILES);
    
    // Format the code snippets
    const codeSnippets = selectedFiles.map(file => 
      `File: ${file.path}\n\`\`\`\n${file.content}\n\`\`\``
    ).join('\n\n');
    
    // Format CVE information
    const cveInfo = vulnerability.cveIds && vulnerability.cveIds.length > 0 
      ? vulnerability.cveIds.join(', ') 
      : 'No specific CVE';
    
    // Prepare the improved prompt with more specific guidance
    return `You are an expert security analyst identifying potential vulnerabilities in code.

VULNERABILITY DETAILS:
ID: ${vulnerability.id}
Summary: ${vulnerability.summary || 'Not provided'}
Details: ${vulnerability.details || 'Not provided'}
CVE(s): ${cveInfo}

CODE TO ANALYZE:
${codeSnippets}

TASK:
Analyze the above code to determine if it contains the specified vulnerability.

ANALYSIS GUIDELINES:
1. Focus specifically on the vulnerability type mentioned above.
2. Look for concrete evidence in the code, such as:
   - User input not being properly sanitized or validated
   - Dangerous functions or API calls
   - Lack of proper security controls
   - Insecure coding patterns specific to this vulnerability
3. Do not flag issues unrelated to the specific vulnerability type.
4. Consider both direct evidence (e.g., obvious flaws) and indirect indicators (e.g., risky patterns).
5. Only identify the vulnerability as present if you are confident based on code evidence.

RESPONSE FORMAT:
HEADLINE: [Brief, descriptive title about the vulnerability finding - be specific]
ANALYSIS: [Detailed technical analysis with code references explaining why this is or isn't vulnerable]
RELEVANT_CVE: [Most relevant CVE or vulnerability type identified]
CONCERNED_FUNCTIONS: [Comma-separated list of specific vulnerable function names]
CONCERNED_FILES: [Comma-separated list of vulnerable filenames]
CLASSIFICATION: [Classification must be one of these exact values: "very promising" (strong evidence of vulnerability), "slightly promising" (some concerning patterns but inconclusive), "not promising" (no significant evidence found)]

EXAMPLE PATTERNS TO LOOK FOR:
- For XSS (CWE-79): Unescaped user input rendered to HTML/DOM
- For SQL Injection (CWE-89): User input directly concatenated into SQL queries
- For Command Injection (CWE-78): User input passed to exec/system functions
- For Path Traversal (CWE-22): Unsanitized file paths from user input
- For Information Disclosure (CWE-200): Sensitive data in logs, responses, or error messages

Base your analysis strictly on evidence in the code. Be thorough but concise.`;
  }

  /**
   * Parses the LLM response into structured data
   */
  parseLLMResponse(response, vulnerability) {
    const result = {
      vulnerabilityId: vulnerability.id,
      headline: '',
      analysis: '',
      cve: '',
      concernedFunctions: [],
      concernedFiles: [],
      classification: 'not promising' // default
    };
    
    // Extract the headline
    const headlineMatch = response.match(/HEADLINE:\s*(.+?)(?=\n|ANALYSIS:)/s);
    if (headlineMatch) {
      result.headline = headlineMatch[1].trim();
    }
    
    // Extract the analysis
    const analysisMatch = response.match(/ANALYSIS:\s*(.+?)(?=\n|RELEVANT_CVE:)/s);
    if (analysisMatch) {
      result.analysis = analysisMatch[1].trim();
    }
    
    // Extract the CVE
    const cveMatch = response.match(/RELEVANT_CVE:\s*(.+?)(?=\n|CONCERNED_FUNCTIONS:)/s);
    if (cveMatch) {
      result.cve = cveMatch[1].trim();
    }
    
    // Extract concerned functions
    const functionsMatch = response.match(/CONCERNED_FUNCTIONS:\s*(.+?)(?=\n|CONCERNED_FILES:)/s);
    if (functionsMatch) {
      result.concernedFunctions = functionsMatch[1]
        .split(',')
        .map(func => func.trim())
        .filter(Boolean);
    }
    
    // Extract concerned files
    const filesMatch = response.match(/CONCERNED_FILES:\s*(.+?)(?=\n|CLASSIFICATION:)/s);
    if (filesMatch) {
      result.concernedFiles = filesMatch[1]
        .split(',')
        .map(file => file.trim())
        .filter(Boolean);
    }
    
    // Extract classification
    const classMatch = response.match(/CLASSIFICATION:\s*(.+?)(?=\n|$)/s);
    if (classMatch) {
      const classification = classMatch[1].trim().toLowerCase();
      if (["very promising", "slightly promising", "not promising"].includes(classification)) {
        result.classification = classification;
      }
    }
    
    return result;
  }

  /**
   * Stores evaluation results in the database
   */
  async storeEvaluationResult(repoId, versionId, vulnId, evaluationResult) {
    const session = this.driver.session();
    try {
      await session.run(`
        MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version {id: $versionId})
        MATCH (vuln:Vulnerability {id: $vulnId})
        MERGE (e:LLMEvaluation {
          id: $repoId + '_' + $versionId + '_' + $vulnId
        })
        SET e.headline = $headline,
            e.analysis = $analysis,
            e.cve = $cve,
            e.concernedFunctions = $concernedFunctions,
            e.concernedFiles = $concernedFiles,
            e.classification = $classification,
            e.evaluatedAt = datetime()
        MERGE (v)-[:HAS_EVALUATION]->(e)
        MERGE (e)-[:EVALUATES]->(vuln)
        RETURN e
      `, {
        repoId,
        versionId,
        vulnId,
        headline: evaluationResult.headline,
        analysis: evaluationResult.analysis,
        cve: evaluationResult.cve,
        concernedFunctions: evaluationResult.concernedFunctions,
        concernedFiles: evaluationResult.concernedFiles,
        classification: evaluationResult.classification
      });
    } finally {
      await session.close();
    }
  }
  
  /**
   * Stores evaluation results directly on the repository node (for repositories without versions)
   */
  async storeRepositoryEvaluationResult(repoId, vulnId, evaluationResult) {
    const session = this.driver.session();
    try {
      await session.run(`
        MATCH (r:Repository {id: $repoId})
        MATCH (vuln:Vulnerability {id: $vulnId})
        MERGE (e:LLMEvaluation {
          id: $repoId + '_direct_' + $vulnId
        })
        SET e.headline = $headline,
            e.analysis = $analysis,
            e.cve = $cve,
            e.concernedFunctions = $concernedFunctions,
            e.concernedFiles = $concernedFiles,
            e.classification = $classification,
            e.evaluatedAt = datetime()
        MERGE (r)-[:HAS_EVALUATION]->(e)
        MERGE (e)-[:EVALUATES]->(vuln)
        RETURN e
      `, {
        repoId,
        vulnId,
        headline: evaluationResult.headline,
        analysis: evaluationResult.analysis,
        cve: evaluationResult.cve,
        concernedFunctions: evaluationResult.concernedFunctions,
        concernedFiles: evaluationResult.concernedFiles,
        classification: evaluationResult.classification
      });
    } finally {
      await session.close();
    }
  }

  /**
   * Calculate evaluation metrics for LLM performance (bonus feature)
   */
  async calculateEvaluationMetrics() {
    const session = this.driver.session();
    try {
      // Get all evaluations
      const result = await session.run(`
        MATCH (e:LLMEvaluation)
        RETURN e.classification as classification, count(*) as count
      `);
      
      // Calculate distribution of classifications
      const metrics = {
        totalEvaluations: 0,
        classificationDistribution: {
          'very promising': 0,
          'slightly promising': 0,
          'not promising': 0
        },
        precision: 0,
        recall: 0,
        f1Score: 0
      };
      
      result.records.forEach(record => {
        const classification = record.get('classification');
        // Use toNumber() instead of toInt() for Neo4j integer conversion
        const count = record.get('count').toNumber ? record.get('count').toNumber() : parseInt(record.get('count'));
        
        if (metrics.classificationDistribution.hasOwnProperty(classification)) {
          metrics.classificationDistribution[classification] = count;
          metrics.totalEvaluations += count;
        }
      });
      
      // For precision, recall, and F1-score, we would need ground truth data
      // Since that's not available, we'll return the basic metrics
      
      return metrics;
    } finally {
      await session.close();
    }
  }

  /**
   * Emit progress updates during vulnerability evaluation
   * @param {string} repoId - Repository ID
   * @param {object} progress - Progress details
   */
  emitProgress(repoId, progress) {
    // Ensure repoId is valid
    if (!repoId) {
      console.warn('Cannot emit progress for undefined repository ID');
      return;
    }
    
    // Add timestamp if not already present
    if (!progress.timestamp) {
      progress.timestamp = new Date().toISOString();
    }
    
    // Log progress to console
    console.log(`[${repoId}] ${progress.status}: ${progress.message}`);
    
    // Emit custom event that can be listened to by UI components
    const progressEvent = new CustomEvent('llm-evaluation-progress', {
      detail: {
        repositoryId: repoId,
        progress: progress
      }
    });
    
    // Dispatch the event so it can be listened to throughout the application
    window.dispatchEvent(progressEvent);
    
    // Also store progress in session storage for persistence
    try {
      const storageKey = `llm_progress_${repoId}`;
      const existingProgress = JSON.parse(sessionStorage.getItem(storageKey) || '[]');
      existingProgress.push(progress);
      
      // Keep only the last 20 progress updates to avoid storage issues
      const trimmedProgress = existingProgress.slice(-20);
      sessionStorage.setItem(storageKey, JSON.stringify(trimmedProgress));
    } catch (error) {
      console.error('Error storing progress in session storage:', error);
    }
  }
  
  /**
   * Get progress history for a repository
   * @param {string} repoId - Repository ID
   * @returns {Array} - Array of progress updates
   */
  getProgressHistory(repoId) {
    try {
      const storageKey = `llm_progress_${repoId}`;
      return JSON.parse(sessionStorage.getItem(storageKey) || '[]');
    } catch (error) {
      console.error('Error retrieving progress history:', error);
      return [];
    }
  }
  
  /**
   * Analyze uploaded files and evaluate vulnerabilities
   * @param {Array} files - Array of uploaded files
   * @returns {Promise<object>} - Evaluation results
   */
  async analyzeUploadedFiles(files) {
    try {
      // Generate a temporary repository ID for tracking progress
      const tempRepoId = `upload_${new Date().getTime()}`;
      
      // Create initial progress object
      const progress = {
        status: 'starting',
        message: 'Starting analysis of uploaded files',
        completed: 0,
        total: files.length,
        timestamp: new Date().toISOString()
      };
      
      // Emit progress update
      this.emitProgress(tempRepoId, progress);
      
      // Process uploaded files
      progress.status = 'processing_files';
      progress.message = `Processing ${files.length} uploaded files`;
      this.emitProgress(tempRepoId, progress);
      
      const processedFiles = [];
      
      // Process each file
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        // Update progress
        progress.completed = i;
        progress.message = `Processing file ${i + 1}/${files.length}: ${file.name}`;
        this.emitProgress(tempRepoId, progress);
        
        // Read file content
        const content = await this.readFileContent(file);
        
        processedFiles.push({
          path: file.name,
          content: content,
          mimeType: file.type || 'text/plain',
          size: file.size
        });
      }
      
      // Filter code files
      const codeFiles = this.filterCodeFiles(processedFiles);
      
      // Update progress
      progress.status = 'analyzing_code';
      progress.message = `Analyzing ${codeFiles.length} code files`;
      this.emitProgress(tempRepoId, progress);
      
      // Create a repository entry for the uploaded code
      const repoId = await this.createRepositoryForUploadedFiles(codeFiles, tempRepoId);
      
      // Get relevant vulnerabilities
      progress.status = 'fetching_vulnerabilities';
      progress.message = 'Identifying relevant vulnerabilities';
      this.emitProgress(repoId, progress);
      
      const vulnerabilities = await this.getCommonVulnerabilities();
      
      // Evaluate vulnerabilities
      progress.status = 'evaluating';
      progress.total = vulnerabilities.length;
      progress.completed = 0;
      progress.message = `Starting evaluation of ${vulnerabilities.length} vulnerabilities`;
      this.emitProgress(repoId, progress);
      
      const evaluationResults = [];
      
      for (const [index, vuln] of vulnerabilities.entries()) {
        // Update progress for current vulnerability
        progress.completed = index;
        progress.message = `Evaluating vulnerability ${index + 1}/${vulnerabilities.length}: ${vuln.id}`;
        this.emitProgress(repoId, progress);
        
        const result = await this.evaluateVulnerabilityWithLLM(codeFiles, vuln);
        evaluationResults.push(result);
        
        // Store the evaluation result
        await this.storeRepositoryEvaluationResult(repoId, vuln.id, result);
        
        // Update progress after completion
        progress.message = `Completed ${index + 1}/${vulnerabilities.length} vulnerabilities`;
        this.emitProgress(repoId, progress);
      }
      
      // Mark completion
      progress.status = 'completed';
      progress.completed = vulnerabilities.length;
      progress.message = `Completed evaluation of ${vulnerabilities.length} vulnerabilities`;
      this.emitProgress(repoId, progress);
      
      return {
        repositoryId: repoId,
        evaluationResults
      };
    } catch (error) {
      console.error('Error analyzing uploaded files:', error);
      throw error;
    }
  }
  
  /**
   * Read content from an uploaded file
   * @param {File} file - The uploaded file
   * @returns {Promise<string>} - File content as string
   */
  async readFileContent(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (event) => {
        resolve(event.target.result);
      };
      
      reader.onerror = (error) => {
        reject(error);
      };
      
      reader.readAsText(file);
    });
  }
  
  /**
   * Create a repository entry for uploaded files
   * @param {Array} files - Processed files
   * @param {string} tempRepoId - Temporary repository ID
   * @returns {Promise<string>} - New repository ID
   */
  async createRepositoryForUploadedFiles(files, tempRepoId) {
    const session = this.driver.session();
    try {
      // Extract repository name from files if possible
      let repoName = 'Uploaded Code';
      
      // Look for package.json to get better repository name
      const packageFile = files.find(file => file.path === 'package.json' || file.path.endsWith('/package.json'));
      if (packageFile) {
        try {
          const packageData = JSON.parse(packageFile.content);
          if (packageData.name) {
            repoName = packageData.name;
          }
        } catch (e) {
          console.error('Error parsing package.json:', e);
        }
      }
      
      // Generate a unique repository ID
      const repoId = `upload_${repoName.replace(/\s+/g, '_')}_${new Date().getTime()}`;
      
      // Create repository node with files embedded
      await session.run(`
        CREATE (r:Repository {
          id: $repoId,
          name: $repoName,
          url: 'local-upload',
          source: 'upload',
          uploadedAt: datetime(),
          fileCount: $fileCount
        })
        RETURN r
      `, {
        repoId,
        repoName,
        fileCount: files.length
      });
      
      // Update progress to use the new repoId
      const progress = {
        status: 'repository_created',
        message: `Created repository ${repoName} with ID ${repoId}`,
        timestamp: new Date().toISOString()
      };
      
      // Emit progress with new ID but also with temp ID so UI can transition
      this.emitProgress(repoId, progress);
      this.emitProgress(tempRepoId, {
        ...progress,
        newRepositoryId: repoId // Signal to UI that ID has changed
      });
      
      return repoId;
    } finally {
      await session.close();
    }
  }

  /**
   * Get repository ID from URL or name
   * @param {string} repoUrlOrName - Repository URL or name
   * @returns {Promise<string>} - Repository ID
   */
  async getRepositoryId(repoUrlOrName) {
    if (!repoUrlOrName) {
      throw new Error('Repository URL or name is required');
    }
    
    // Check if this is already a valid repository ID format
    if (repoUrlOrName.startsWith('upload_') || repoUrlOrName.startsWith('github_')) {
      return repoUrlOrName;
    }
    
    const session = this.driver.session();
    try {
      // Check if repository exists by URL or name
      const result = await session.run(`
        MATCH (r:Repository)
        WHERE r.url = $repoUrlOrName OR r.id = $repoUrlOrName OR r.name = $repoUrlOrName
        RETURN r.id as id
        LIMIT 1
      `, {
        repoUrlOrName
      });
      
      // If found in database, return the ID
      if (result.records.length > 0) {
        return result.records[0].get('id');
      }
      
      // Not found, create a new repository in the database
      
      // Determine if this is a GitHub URL
      let name = repoUrlOrName;
      let url = repoUrlOrName;
      let source = 'unknown';
      
      // Extract repository name from GitHub URL if applicable
      if (repoUrlOrName.includes('github.com')) {
        source = 'github';
        // Parse GitHub URL to extract owner and repo
        const urlParts = repoUrlOrName.split('/');
        if (urlParts.length >= 5) {
          const owner = urlParts[3];
          const repo = urlParts[4].replace('.git', '');
          name = `${owner}/${repo}`;
          
          // Create a standard format for GitHub repository IDs
          const newRepoId = `github_${owner}_${repo}`;
          
          // Create the repository node
          await session.run(`
            CREATE (r:Repository {
              id: $repoId,
              name: $name,
              url: $url,
              source: $source,
              createdAt: datetime()
            })
            RETURN r
          `, {
            repoId: newRepoId,
            name,
            url,
            source
          });
          
          return newRepoId;
        }
      }
      
      // For non-GitHub repositories or invalid GitHub URLs, create a generic entry
      const genericId = `repo_${name.replace(/\s+/g, '_').replace(/[^\w-]/g, '')}_${new Date().getTime()}`;
      
      await session.run(`
        CREATE (r:Repository {
          id: $repoId,
          name: $name,
          url: $url,
          source: $source,
          createdAt: datetime()
        })
        RETURN r
      `, {
        repoId: genericId,
        name,
        url,
        source
      });
      
      return genericId;
    } finally {
      await session.close();
    }
  }
}

export default LLMVulnerabilityEvaluator;

import { apiClient } from './axiosConfig';

export class LLMVulnerabilityEvaluator {
  constructor(driver) {
    this.driver = driver;
    this.ollamaApiUrl = import.meta.env.VITE_OLLAMA_API_URL || 'http://localhost:11434';
    this.ollamaModel = import.meta.env.VITE_OLLAMA_MODEL || 'llama2:latest';
    
    // Blocklisted extensions and paths for files to exclude from analysis
    this.blockedExtensions = [
      '.css', '.lock', '.md', '.min.js', '.scss', '.txt', '.rst', 
      '.json', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', 
      '.eot', '.ttf', '.woff', '.woff2', '.map', '.yaml', '.yml'
    ];
    
    this.maxFileSize = 200000; // 200,000 characters limit for files
    
    // Allowed extensions for GitHub API file fetching
    this.allowedExtensions = ['.js', '.py', '.java', '.c', '.cpp', '.h', '.hpp', '.cs', '.rb', '.php', '.ts', '.go', '.rs'];
  }
  
  /**
   * Evaluates a repository revision for vulnerabilities using LLM
   * @param {string} repoId - The ID of the repository to evaluate
   * @param {string} versionId - The specific version/revision to evaluate
   * @returns {Promise<object>} - The evaluation results
   */
  async evaluateRevision(repoId, versionId) {
    try {
      // 1. Fetch the code files for this revision
      const codeFiles = await this.getCodeFilesForRevision(repoId, versionId);
      
      // 2. Get relevant CVEs/CWEs for this codebase
      const vulnerabilities = await this.getRelevantVulnerabilities(repoId, versionId);
      
      // 3. For each vulnerability, run the LLM evaluation
      const evaluationResults = [];
      
      for (const vuln of vulnerabilities) {
        const result = await this.evaluateVulnerabilityWithLLM(codeFiles, vuln);
        evaluationResults.push(result);
        
        // Store the evaluation result in the database
        await this.storeEvaluationResult(repoId, versionId, vuln.id, result);
      }
      
      return {
        repositoryId: repoId,
        versionId: versionId,
        evaluationResults
      };
    } catch (error) {
      console.error('Error evaluating revision:', error);
      throw error;
    }
  }
  
  /**
   * Evaluates a repository for vulnerabilities using LLM without requiring a specific version
   * @param {string} repoId - The ID of the repository to evaluate
   * @returns {Promise<object>} - The evaluation results
   */
  async evaluateRepository(repoId) {
    try {
      // 1. Fetch the code files for this repository directly
      const codeFiles = await this.getCodeFilesForRepository(repoId);
      
      // 2. Get relevant CVEs/CWEs for this codebase
      const vulnerabilities = await this.getRelevantVulnerabilitiesForRepo(repoId);
      
      // 3. For each vulnerability, run the LLM evaluation
      const evaluationResults = [];
      
      for (const vuln of vulnerabilities) {
        const result = await this.evaluateVulnerabilityWithLLM(codeFiles, vuln);
        evaluationResults.push(result);
        
        // Store the evaluation result in the database directly on the repository
        await this.storeRepositoryEvaluationResult(repoId, vuln.id, result);
      }
      
      return {
        repositoryId: repoId,
        evaluationResults
      };
    } catch (error) {
      console.error('Error evaluating repository:', error);
      throw error;
    }
  }
  
  /**
   * Fetches code files for a specific repository revision
   * Applies filtering rules based on requirements
   */  
  async getCodeFilesForRevision(repoId, versionId) {
    const session = this.driver.session();
    try {
      const result = await session.run(`
        MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version {id: $versionId})-[:CONTAINS]->(f:File)
        RETURN f.path AS path, f.content AS content, f.mime_type AS mimeType, f.size AS size
      `, {
        repoId,
        versionId
      });
      
      return this.filterCodeFiles(result.records.map(record => ({
        path: record.get('path'),
        content: record.get('content'),
        mimeType: record.get('mimeType'),
        size: record.get('size')
      })));
    } finally {
      await session.close();
    }
  }
  
  /**
   * Fetches code files for a repository (without specifying version)
   * Applies filtering rules based on requirements
   */  
  async getCodeFilesForRepository(repoId) {
    // Validate the repository ID before proceeding
    if (!repoId) {
      console.error('Repository ID is null or undefined in getCodeFilesForRepository');
      return [];
    }

    console.log(`Starting code file retrieval for repository ID: ${repoId}`);
    
    // First, try to get files from Neo4j
    const session = this.driver.session();
    try {
      // Try multiple relationship patterns to find files
      // This handles different database schemas that might exist
      const result = await session.run(`
        // Try direct relationship
        MATCH (r:Repository {id: $repoId})-[:CONTAINS]->(f:File)
        RETURN f.path AS path, f.content AS content, f.mime_type AS mimeType, f.size AS size
        
        UNION
        
        // Try through versions
        MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version)-[:CONTAINS]->(f:File)
        RETURN f.path AS path, f.content AS content, f.mime_type AS mimeType, f.size AS size
        
        UNION
        
        // Try direct file content if stored on repository
        MATCH (r:Repository {id: $repoId})
        WHERE r.files IS NOT NULL
        UNWIND r.files AS file
        RETURN file.path AS path, file.content AS content, file.mime_type AS mimeType, file.size AS size
      `, {
        repoId
      });
      
      const files = result.records.map(record => ({
        path: record.get('path'),
        content: record.get('content'),
        mimeType: record.get('mimeType'),
        size: record.get('size')
      }));
      
      console.log(`Found ${files.length} total files for repository ${repoId} (before filtering)`);
      
      // If we found files in Neo4j, filter and return them
      if (files.length > 0) {
        return this.filterCodeFiles(files);
      }
      
      // If no files were found in Neo4j, and the ID looks like a GitHub URL, try fetching directly from GitHub
      if (repoId.includes('github.com')) {
        console.log(`No files found in Neo4j for ${repoId}, attempting to fetch from GitHub...`);
        const githubFiles = await this.fetchFilesFromGitHub(repoId);
        return this.filterCodeFiles(githubFiles);
      }
      
      // If we still don't have files, return an empty array
      return [];
    } catch (error) {
      console.error(`Error retrieving files for repository ${repoId}:`, error);
      
      // If there was an error with Neo4j query but the ID looks like a GitHub URL,
      // try fetching from GitHub as a fallback
      if (repoId.includes('github.com')) {
        console.log(`Error retrieving from Neo4j for ${repoId}, trying GitHub instead...`);
        try {
          const githubFiles = await this.fetchFilesFromGitHub(repoId);
          return this.filterCodeFiles(githubFiles);
        } catch (githubError) {
          console.error(`Failed to fetch from GitHub as well:`, githubError);
        }
      }
      
      return [];
    } finally {
      await session.close();
    }
  }
  
  /**
   * Fetches code files directly from GitHub API when they're not available in Neo4j
   * @param {string} repoUrl - The GitHub repository URL
   * @returns {Promise<Array>} - Array of code files
   */
  async fetchFilesFromGitHub(repoUrl) {
    try {
      // Extract owner and repo from URL
      // URL format: https://github.com/owner/repo
      const urlParts = repoUrl.split('/');
      if (urlParts.length < 5) {
        console.error('Invalid GitHub URL format:', repoUrl);
        return [];
      }
      
      const owner = urlParts[3];
      const repo = urlParts[4];
      
      console.log(`Attempting to fetch files directly from GitHub for ${owner}/${repo}`);
      
      // First, get repository contents at the root level
      const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents`);
      
      if (!response.ok) {
        console.error(`GitHub API error: ${response.status}`);
        return [];
      }
      
      const contents = await response.json();
      
      // Process files and fetch content
      const codeFiles = [];
      const MAX_FILES = 10; // Limit the number of files to process
      let fileCount = 0;
      
      for (const item of contents) {
        if (item.type === 'file') {
          // Check file extension
          const extension = item.name.substring(item.name.lastIndexOf('.')).toLowerCase();
          if (this.allowedExtensions.includes(extension) && !this.blockedExtensions.includes(extension)) {
            if (fileCount >= MAX_FILES) break;
            
            // Fetch file content
            try {
              const fileResponse = await fetch(item.download_url);
              if (fileResponse.ok) {
                const content = await fileResponse.text();
                
                // Add to code files
                codeFiles.push({
                  path: item.path,
                  content: content,
                  mimeType: 'text/plain',
                  size: content.length
                });
                
                fileCount++;
                console.log(`Successfully fetched file ${item.path} from GitHub`);
              }
            } catch (error) {
              console.error(`Error fetching file ${item.path}:`, error);
            }
          }
        }
      }
      
      console.log(`Found ${codeFiles.length} code files from GitHub API`);
      return codeFiles;
    } catch (error) {
      console.error('Error fetching from GitHub:', error);
      return [];
    }
  }
  
  /**
   * Common method to filter code files based on rules
   */
  filterCodeFiles(files) {
    // Apply filtering rules:
    // 1. Exclude files with blocklisted extensions
    // 2. Exclude files in paths starting with "."
    // 3. Exclude files larger than 200,000 characters
    // 4. Exclude files with non-text MIME types
    return files.filter(file => {
      if (!file.path) return false;
      
      // Check file extension
      const extension = file.path.substring(file.path.lastIndexOf('.')).toLowerCase();
      if (this.blockedExtensions.includes(extension)) return false;
      
      // Check path for dot files/directories
      const pathParts = file.path.split('/');
      if (pathParts.some(part => part.startsWith('.'))) return false;
      
      // Check file size
      if (file.content && file.content.length > this.maxFileSize) return false;
      
      // Check MIME type
      if (file.mimeType && !file.mimeType.startsWith('text/')) {
        // Try to identify code files not properly recognized by MIME type
        if (!file.path.match(/\.(js|ts|jsx|tsx|py|java|c|cpp|h|hpp|cs|rb|php|html|xml|go|rust|sol)$/i)) {
          return false;
        }
      }
      
      return true;
    });
  }
  
  /**
   * Gets relevant vulnerabilities for a repository version
   */
  async getRelevantVulnerabilities(repoId, versionId) {
    const session = this.driver.session();
    try {
      const result = await session.run(`
        MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version {id: $versionId})
        MATCH (v)-[:USES_PACKAGE]->(p:Package)<-[:AFFECTS]-(vuln:Vulnerability)
        OPTIONAL MATCH (c:CVE)-[:IDENTIFIED_AS]->(vuln)
        RETURN vuln, collect(DISTINCT c.id) AS cveIds
      `, {
        repoId,
        versionId
      });
      
      return result.records.map(record => {
        const vuln = record.get('vuln').properties;
        return {
          ...vuln,
          cveIds: record.get('cveIds')
        };
      });
    } finally {
      await session.close();
    }
  }
  
  /**
   * Gets relevant vulnerabilities for a repository without needing a specific version
   */
  async getRelevantVulnerabilitiesForRepo(repoId) {
    const session = this.driver.session();
    try {
      const result = await session.run(`
        MATCH (r:Repository {id: $repoId})-[:USES_PACKAGE]->(p:Package)<-[:AFFECTS]-(vuln:Vulnerability)
        OPTIONAL MATCH (c:CVE)-[:IDENTIFIED_AS]->(vuln)
        RETURN vuln, collect(DISTINCT c.id) AS cveIds
        UNION
        MATCH (r:Repository {id: $repoId})
        WITH r
        MATCH (vuln:Vulnerability)
        WHERE vuln.id IN ['CWE-79', 'CWE-89', 'CWE-20', 'CWE-78', 'CWE-22']
        OPTIONAL MATCH (c:CVE)-[:IDENTIFIED_AS]->(vuln)
        RETURN vuln, collect(DISTINCT c.id) AS cveIds
      `, {
        repoId
      });
      
      // If no vulnerabilities are found, return common vulnerabilities
      if (result.records.length === 0) {
        return this.getCommonVulnerabilities();
      }
      
      return result.records.map(record => {
        const vuln = record.get('vuln').properties;
        return {
          ...vuln,
          cveIds: record.get('cveIds')
        };
      });
    } finally {
      await session.close();
    }
  }

  /**
   * Evaluates a vulnerability against codebase using LLM
   */
  async evaluateVulnerabilityWithLLM(codeFiles, vulnerability) {
    try {
      // Construct the prompt for the LLM
      const prompt = this.constructLLMPrompt(codeFiles, vulnerability);
      
      // Get environment variables directly to ensure consistency with upload functionality
      const ollamaApiUrl = import.meta.env.VITE_OLLAMA_API_URL || 'http://localhost:11434';
      const ollamaModel = import.meta.env.VITE_OLLAMA_MODEL || 'llama2:latest';
      
      // Call Ollama API using direct environment variables
      const response = await fetch(`${ollamaApiUrl}/api/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: ollamaModel,
          prompt: prompt,
          stream: false
        })
      });
      
      if (!response.ok) {
        throw new Error(`Ollama API error: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Parse the response to extract structured data
      return this.parseLLMResponse(data.response, vulnerability);
    } catch (error) {
      console.error('Error calling LLM:', error);
      return {
        vulnerabilityId: vulnerability.id,
        headline: 'Error during evaluation',
        analysis: `Failed to evaluate: ${error.message}`,
        cve: vulnerability.cveIds?.[0] || 'Unknown',
        concernedFunctions: [],
        concernedFiles: [],
        classification: 'not promising',
        error: error.message
      };
    }
  }
  
  /**
   * Returns common vulnerability types for evaluation when none are found in the database
   */
  getCommonVulnerabilities() {
    // Get a list of common vulnerabilities to test against code
    return [
      {
        id: 'CWE-79',
        summary: 'Cross-site Scripting (XSS)',
        details: 'The software does not properly neutralize user-controllable input before it is placed in output that is used as a web page that is served to other users.',
        cveIds: ['CVE-2021-27889', 'CVE-2020-11022']
      },
      {
        id: 'CWE-89',
        summary: 'SQL Injection',
        details: 'The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize special elements that could modify the intended SQL command.',
        cveIds: ['CVE-2020-9480', 'CVE-2020-13937']
      },
      {
        id: 'CWE-20',
        summary: 'Improper Input Validation',
        details: 'The software does not validate or incorrectly validates input that can affect the control flow or data flow of a program.',
        cveIds: ['CVE-2021-21881', 'CVE-2021-1675']
      },
      {
        id: 'CWE-400',
        summary: 'Uncontrolled Resource Consumption',
        details: 'The software does not properly restrict the size or amount of resources that are requested or influenced by an actor, which can be used to consume more resources than intended.',
        cveIds: ['CVE-2020-8870', 'CVE-2019-1010266']
      },
      {
        id: 'CWE-200',
        summary: 'Information Exposure',
        details: 'The software exposes sensitive information to an actor that is not explicitly authorized to have access to that information.',
        cveIds: ['CVE-2021-21972', 'CVE-2020-28074']
      }
    ];
  }
  
  /**
   * Constructs a prompt for the LLM based on the codebase and vulnerability
   */
  constructLLMPrompt(codeFiles, vulnerability) {
    // Include only the first N files to avoid token limits
    const MAX_FILES = 10;
    const selectedFiles = codeFiles.slice(0, MAX_FILES);
    
    // Format the code snippets
    const codeSnippets = selectedFiles.map(file => 
      `File: ${file.path}\n\`\`\`\n${file.content}\n\`\`\``
    ).join('\n\n');
    
    // Format CVE information
    const cveInfo = vulnerability.cveIds && vulnerability.cveIds.length > 0 
      ? vulnerability.cveIds.join(', ') 
      : 'No specific CVE';
    
    // Prepare the prompt
    return `You are a security expert analyzing code for potential vulnerabilities.
    
VULNERABILITY DETAILS:
ID: ${vulnerability.id}
Summary: ${vulnerability.summary || 'Not provided'}
Details: ${vulnerability.details || 'Not provided'}
CVE(s): ${cveInfo}

CODE TO ANALYZE:
${codeSnippets}

INSTRUCTIONS:
1. Analyze the code for the specified vulnerability.
2. Provide a concise headline for the vulnerability.
3. Write a detailed analysis of how the vulnerability affects this codebase.
4. Identify the most relevant CVE type for this vulnerability.
5. List the most concerned functions in the code (those most likely affected).
6. List the most concerned filenames in the codebase.
7. Classify the likelihood of this vulnerability being present as one of: "very promising", "slightly promising", or "not promising".

Format your response exactly like this:
HEADLINE: [Vulnerability headline]
ANALYSIS: [Detailed analysis]
RELEVANT_CVE: [Most relevant CVE type]
CONCERNED_FUNCTIONS: [List of functions, comma-separated]
CONCERNED_FILES: [List of filenames, comma-separated]
CLASSIFICATION: [very promising|slightly promising|not promising]

Be precise and concise. Base your classification strictly on the evidence in the code.`;
  }

  /**
   * Parses the LLM response into structured data
   */
  parseLLMResponse(response, vulnerability) {
    const result = {
      vulnerabilityId: vulnerability.id,
      headline: '',
      analysis: '',
      cve: '',
      concernedFunctions: [],
      concernedFiles: [],
      classification: 'not promising' // default
    };
    
    // Extract the headline
    const headlineMatch = response.match(/HEADLINE:\s*(.+?)(?=\n|ANALYSIS:)/s);
    if (headlineMatch) {
      result.headline = headlineMatch[1].trim();
    }
    
    // Extract the analysis
    const analysisMatch = response.match(/ANALYSIS:\s*(.+?)(?=\n|RELEVANT_CVE:)/s);
    if (analysisMatch) {
      result.analysis = analysisMatch[1].trim();
    }
    
    // Extract the CVE
    const cveMatch = response.match(/RELEVANT_CVE:\s*(.+?)(?=\n|CONCERNED_FUNCTIONS:)/s);
    if (cveMatch) {
      result.cve = cveMatch[1].trim();
    }
    
    // Extract concerned functions
    const functionsMatch = response.match(/CONCERNED_FUNCTIONS:\s*(.+?)(?=\n|CONCERNED_FILES:)/s);
    if (functionsMatch) {
      result.concernedFunctions = functionsMatch[1]
        .split(',')
        .map(func => func.trim())
        .filter(Boolean);
    }
    
    // Extract concerned files
    const filesMatch = response.match(/CONCERNED_FILES:\s*(.+?)(?=\n|CLASSIFICATION:)/s);
    if (filesMatch) {
      result.concernedFiles = filesMatch[1]
        .split(',')
        .map(file => file.trim())
        .filter(Boolean);
    }
    
    // Extract classification
    const classMatch = response.match(/CLASSIFICATION:\s*(.+?)(?=\n|$)/s);
    if (classMatch) {
      const classification = classMatch[1].trim().toLowerCase();
      if (["very promising", "slightly promising", "not promising"].includes(classification)) {
        result.classification = classification;
      }
    }
    
    return result;
  }

  /**
   * Stores evaluation results in the database
   */
  async storeEvaluationResult(repoId, versionId, vulnId, evaluationResult) {
    const session = this.driver.session();
    try {
      await session.run(`
        MATCH (r:Repository {id: $repoId})-[:HAS_VERSION]->(v:Version {id: $versionId})
        MATCH (vuln:Vulnerability {id: $vulnId})
        MERGE (e:LLMEvaluation {
          id: $repoId + '_' + $versionId + '_' + $vulnId
        })
        SET e.headline = $headline,
            e.analysis = $analysis,
            e.cve = $cve,
            e.concernedFunctions = $concernedFunctions,
            e.concernedFiles = $concernedFiles,
            e.classification = $classification,
            e.evaluatedAt = datetime()
        MERGE (v)-[:HAS_EVALUATION]->(e)
        MERGE (e)-[:EVALUATES]->(vuln)
        RETURN e
      `, {
        repoId,
        versionId,
        vulnId,
        headline: evaluationResult.headline,
        analysis: evaluationResult.analysis,
        cve: evaluationResult.cve,
        concernedFunctions: evaluationResult.concernedFunctions,
        concernedFiles: evaluationResult.concernedFiles,
        classification: evaluationResult.classification
      });
    } finally {
      await session.close();
    }
  }
  
  /**
   * Stores evaluation results directly on the repository node (for repositories without versions)
   */
  async storeRepositoryEvaluationResult(repoId, vulnId, evaluationResult) {
    const session = this.driver.session();
    try {
      await session.run(`
        MATCH (r:Repository {id: $repoId})
        MATCH (vuln:Vulnerability {id: $vulnId})
        MERGE (e:LLMEvaluation {
          id: $repoId + '_direct_' + $vulnId
        })
        SET e.headline = $headline,
            e.analysis = $analysis,
            e.cve = $cve,
            e.concernedFunctions = $concernedFunctions,
            e.concernedFiles = $concernedFiles,
            e.classification = $classification,
            e.evaluatedAt = datetime()
        MERGE (r)-[:HAS_EVALUATION]->(e)
        MERGE (e)-[:EVALUATES]->(vuln)
        RETURN e
      `, {
        repoId,
        vulnId,
        headline: evaluationResult.headline,
        analysis: evaluationResult.analysis,
        cve: evaluationResult.cve,
        concernedFunctions: evaluationResult.concernedFunctions,
        concernedFiles: evaluationResult.concernedFiles,
        classification: evaluationResult.classification
      });
    } finally {
      await session.close();
    }
  }

  /**
   * Calculate evaluation metrics for LLM performance (bonus feature)
   */
  async calculateEvaluationMetrics() {
    const session = this.driver.session();
    try {
      // Get all evaluations
      const result = await session.run(`
        MATCH (e:LLMEvaluation)
        RETURN e.classification as classification, count(*) as count
      `);
      
      // Calculate distribution of classifications
      const metrics = {
        totalEvaluations: 0,
        classificationDistribution: {
          'very promising': 0,
          'slightly promising': 0,
          'not promising': 0
        },
        precision: 0,
        recall: 0,
        f1Score: 0
      };
      
      result.records.forEach(record => {
        const classification = record.get('classification');
        const count = record.get('count').toInt();
        
        if (metrics.classificationDistribution.hasOwnProperty(classification)) {
          metrics.classificationDistribution[classification] = count;
          metrics.totalEvaluations += count;
        }
      });
      
      // For precision, recall, and F1-score, we would need ground truth data
      // Since that's not available, we'll return the basic metrics
      
      return metrics;
    } finally {
      await session.close();
    }
  }
}

export default LLMVulnerabilityEvaluator;
